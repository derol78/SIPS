[
    {
        "id": "3eed00b8c7a9ef73",
        "type": "tab",
        "label": "Flow 3",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "993618586782759e",
        "type": "group",
        "z": "3eed00b8c7a9ef73",
        "name": "1. INPUT LAYER (V12.2 - Type Safe)",
        "style": {
            "stroke": "#92d04f",
            "fill": "#f3f9f0",
            "label": true
        },
        "nodes": [
            "ec87205e3c049379",
            "5b6ca60559792007",
            "336df0324b7df042",
            "edef1cba375fab59",
            "d51bd7fe61f36c76",
            "4e8bfed6d53c7bfa",
            "7bb95e948d7e50a1",
            "f7bbdfd6d1b3c684"
        ],
        "x": -26,
        "y": 59,
        "w": 552,
        "h": 542
    },
    {
        "id": "cf8bf0b14e7e4aa4",
        "type": "group",
        "z": "3eed00b8c7a9ef73",
        "name": "2. LOGIC LAYER (V12.2 - Resource Oriented)",
        "style": {
            "stroke": "#4f8dd0",
            "fill": "#e3f2fd",
            "label": true
        },
        "nodes": [
            "2b88557c7db8812d",
            "e83459563e16abdb",
            "3de6acad5750e825",
            "a820781f81b641a5",
            "a52beea9e11f07c7",
            "24bbf6da4dc3bccc",
            "a8726aa5f03d58ef",
            "73886911443170ec",
            "9cc697e5e2f1d6b3"
        ],
        "x": 554,
        "y": -1,
        "w": 1062,
        "h": 342
    },
    {
        "id": "5192e703de6729fe",
        "type": "group",
        "z": "3eed00b8c7a9ef73",
        "name": "3. OUTPUT LAYER (Sequential + RBE Router)",
        "style": {
            "stroke": "#d04f4f",
            "fill": "#f9f0f0",
            "label": true
        },
        "nodes": [
            "465db2ea43b9bb53",
            "86691c8d33a02da5",
            "fa8fa39964d2d08e",
            "f2183dc2955be820"
        ],
        "x": 1414,
        "y": 59,
        "w": 832,
        "h": 202
    },
    {
        "id": "d4250ce404ec61b6",
        "type": "group",
        "z": "3eed00b8c7a9ef73",
        "name": "4. LOGGING LAYER (InfluxDB - Type Fixed)",
        "style": {
            "stroke": "#999999",
            "fill": "#f0f0f0",
            "label": true
        },
        "nodes": [
            "0e5b7cfa1c0ca96c",
            "5e6e102b39c894df",
            "6c022f6774a4cc71",
            "6977b02bb44346ff",
            "50168a41b8f03124",
            "06b187955acb7b86",
            "63ca7cd6919362ff",
            "0fddf1d214b7d01d",
            "f4994743ff5ad18b",
            "d73df6f2d0a9ded5",
            "2a2cdbd33c3741bf",
            "eeb2e66b55d708c4",
            "57687425891251a8",
            "88d2c26357c74df6",
            "f32dacf6932d3251",
            "70af6cc2a74a0b8c",
            "13a8b24575162bc0",
            "611df54fa9d4dae1",
            "ccb70e46e6a58ebf",
            "3d6eb74669a18ef6",
            "cd97a78245ed03b5",
            "6c59a443ece883cd",
            "a247090378a4af0d",
            "4e3e690d57655ee6",
            "4bca7de47a6d27af",
            "3dac916d4c67f1b4",
            "55f80dab524db438",
            "7d9ec10db76f9143",
            "c7d9301c2825d9e9",
            "1b90e546f47923db",
            "12c3d51f1fec7959",
            "f53d84969b5c6984",
            "fb1667db8e514d0b",
            "0edd2ed72415efc9",
            "2c75eb53e54b7f6d",
            "2f3061b4a04d50ed",
            "70fcb03927189877",
            "74e0c13822ddd416",
            "3e6e52e565bdc32e",
            "1b4f3371b3397cb9",
            "08cf75a83c8610ad",
            "d8f383c26e73f67c",
            "499987080eb7c356"
        ],
        "x": 1014,
        "y": 519,
        "w": 1572,
        "h": 782
    },
    {
        "id": "ec87205e3c049379",
        "type": "mqtt in",
        "z": "3eed00b8c7a9ef73",
        "g": "993618586782759e",
        "name": "IN: Grid Metrics",
        "topic": "spB_app1_v1/BT01-S1-F-S/NDATA/IoT_Edge_1/IoT_Device_1/#",
        "qos": "0",
        "datatype": "json",
        "broker": "fa6a33cd942a9c83",
        "inputs": 0,
        "x": 80,
        "y": 100,
        "wires": [
            [
                "7bb95e948d7e50a1",
                "d73df6f2d0a9ded5",
                "f32dacf6932d3251",
                "70af6cc2a74a0b8c"
            ]
        ]
    },
    {
        "id": "5b6ca60559792007",
        "type": "mqtt in",
        "z": "3eed00b8c7a9ef73",
        "g": "993618586782759e",
        "name": "IN: Homey Loads",
        "topic": "homey/logic/+",
        "qos": "1",
        "broker": "fa6a33cd942a9c83",
        "inputs": 0,
        "x": 80,
        "y": 260,
        "wires": [
            [
                "7bb95e948d7e50a1"
            ]
        ]
    },
    {
        "id": "336df0324b7df042",
        "type": "mqtt in",
        "z": "3eed00b8c7a9ef73",
        "g": "993618586782759e",
        "name": "IN: Shelly Feedback",
        "topic": "shellies/+/relay/0",
        "qos": "1",
        "broker": "fa6a33cd942a9c83",
        "inputs": 0,
        "x": 90,
        "y": 300,
        "wires": [
            [
                "7bb95e948d7e50a1"
            ]
        ]
    },
    {
        "id": "edef1cba375fab59",
        "type": "mqtt in",
        "z": "3eed00b8c7a9ef73",
        "g": "993618586782759e",
        "name": "IN: Go-e Amp Set",
        "topic": "EV-Charger/1/amp",
        "qos": "1",
        "datatype": "auto-detect",
        "broker": "fa6a33cd942a9c83",
        "nl": false,
        "rap": false,
        "inputs": 0,
        "x": 80,
        "y": 360,
        "wires": [
            [
                "7bb95e948d7e50a1"
            ]
        ]
    },
    {
        "id": "d51bd7fe61f36c76",
        "type": "mqtt in",
        "z": "3eed00b8c7a9ef73",
        "g": "993618586782759e",
        "name": "IN: Go-e Energy",
        "topic": "EV-Charger/1/nrg",
        "qos": "1",
        "datatype": "auto-detect",
        "broker": "fa6a33cd942a9c83",
        "nl": false,
        "rap": false,
        "inputs": 0,
        "x": 80,
        "y": 400,
        "wires": [
            [
                "7bb95e948d7e50a1"
            ]
        ]
    },
    {
        "id": "4e8bfed6d53c7bfa",
        "type": "mqtt in",
        "z": "3eed00b8c7a9ef73",
        "g": "993618586782759e",
        "name": "IN: Storage",
        "topic": "system/sips/storage",
        "qos": "1",
        "broker": "fa6a33cd942a9c83",
        "inputs": 0,
        "x": 70,
        "y": 520,
        "wires": [
            [
                "7bb95e948d7e50a1"
            ]
        ]
    },
    {
        "id": "7bb95e948d7e50a1",
        "type": "function",
        "z": "3eed00b8c7a9ef73",
        "g": "993618586782759e",
        "name": "INPUT MAPPER V12",
        "func": "// INPUT MAPPER V13.2 (Fixed Energy Calculation)\n// Merged logic from Flow 35 (New features) with Flow 33 (Working Energy Calc)\n\nlet sips = flow.get(\"sips_state\");\n\n// --- 1. INIT ---\nif (!sips || !sips.loads) {\n    sips = sips || {};\n    // Lägg till frc default: 0 (Neutral)\n    if (!sips.goe) sips.goe = { car: 1, amp: 6, frc: 0 }; \n    if (!sips.tesla) sips.tesla = { amps: 6, actual_amps: 0, state: \"unknown\", charging_state: \"Disconnected\", phases_active: 1 };\n    if (!sips.loads) sips.loads = { vvb: { status: \"off\" }, rad: { status: \"off\" }, avf: { status: \"off\" } };\n    if (!sips.grid) sips.grid = { l1: 0, l2: 0, l3: 0, power: 0, energy_used_hour: 0, minutes_passed: 0 };\n    if (!sips.fuse) sips.fuse = { l1: 0, l2: 0, l3: 0, max: 0 };\n    if (!sips.api) sips.api = { count: 0 };\n}\n\nlet trigger = false;\n\n// --- 2. GO-E INPUTS ---\n\n// A. NRG (Ström & Faser)\nif (msg.topic.includes(\"nrg\") && Array.isArray(msg.payload)) {\n    let nrg = msg.payload;\n    let iL1 = nrg[4]; let iL2 = nrg[5]; let iL3 = nrg[6];\n    sips.tesla.actual_amps = Math.max(iL1, iL2, iL3);\n    sips.tesla.phases_active = (iL2 > 0.5 || iL3 > 0.5) ? 3 : 1;\n    trigger = true;\n}\n// B. AMP (Börvärde)\nelse if (msg.topic.endsWith(\"/amp\")) {\n    let val = parseInt(msg.payload);\n    sips.tesla.amps = val;\n    sips.goe.amp = val;\n    trigger = true;\n}\n// C. CAR (Status)\nelse if (msg.topic.endsWith(\"/car\")) {\n    let status = parseInt(msg.payload);\n    sips.goe.car = status;\n    // Mappa text för debug\n    if (status === 1) sips.tesla.charging_state = \"Disconnected\";\n    else if (status === 2) sips.tesla.charging_state = \"Charging\";\n    else if (status === 3) sips.tesla.charging_state = \"Waiting\";\n    else if (status === 4) sips.tesla.charging_state = \"Complete\";\n    trigger = true;\n}\n// D. FRC (Force State - NY!)\nelse if (msg.topic.endsWith(\"/frc\")) {\n    sips.goe.frc = parseInt(msg.payload);\n    trigger = true;\n}\n\n// --- 3. ÖVRIGA (Shelly/Homey) ---\nelse if (msg.payload && msg.payload.metrics) { // Shelly 3EM\n    let m = msg.payload.metrics;\n    \n    // 1. Uppdatera ström och effekt\n    sips.grid.l1 = m.Current_L1; \n    sips.grid.l2 = m.Current_L2; \n    sips.grid.l3 = m.Current_L3;\n    sips.grid.power = m.Power_Total;\n\n    // 2. BERÄKNA TIM-ENERGI (Hämtat från Flow 33 - FIXEN)\n    if (m.Energy_Total !== undefined) {\n        let currentTotalKwh = parseFloat(m.Energy_Total);\n        let now = new Date();\n        let currentHour = now.getHours();\n        \n        // Hämta sparat state för start-energi\n        let energyState = flow.get(\"sips_energy_state\") || { startEnergy: currentTotalKwh, currentHour: -1 };\n        \n        // Om ny timme: Nollställ startvärdet\n        if (energyState.currentHour !== currentHour) {\n            energyState.currentHour = currentHour;\n            energyState.startEnergy = currentTotalKwh;\n        }\n        \n        // Räkna ut förbrukning\n        let used = currentTotalKwh - energyState.startEnergy;\n        // Skydd mot negativa värden\n        if (used < 0) { used = 0; energyState.startEnergy = currentTotalKwh; }\n        \n        flow.set(\"sips_energy_state\", energyState);\n        \n        // Uppdatera SIPS-variabler som Strategy-noden behöver\n        sips.grid.energy_used_hour = used;\n        sips.grid.minutes_passed = now.getMinutes();\n    }\n    \n    trigger = true;\n}\nelse if (msg.topic.includes(\"shellies/\")) { // Pluggar\n    if (msg.topic.includes(\"vvb1\")) sips.loads.vvb.status = msg.payload;\n    if (msg.topic.includes(\"rad1\")) sips.loads.rad.status = msg.payload;\n    if (msg.topic.includes(\"avf1\")) sips.loads.avf.status = msg.payload;\n}\nelse if (msg.topic === \"system/sips/storage\") { // API Count\n    let data = msg.payload;\n    if (typeof data === \"string\") try { data = JSON.parse(data); } catch(e){}\n    if (data && data.c !== undefined) sips.api.count = data.c;\n}\n\nflow.set(\"sips_state\", sips);\nif (trigger) { msg.sips = sips; return msg; }\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 100,
        "wires": [
            [
                "2b88557c7db8812d"
            ]
        ]
    },
    {
        "id": "2b88557c7db8812d",
        "type": "function",
        "z": "3eed00b8c7a9ef73",
        "g": "cf8bf0b14e7e4aa4",
        "name": "MODEL: Fuse (I2t - Fixed)",
        "func": "let sips = msg.sips;\nlet config = flow.get(\"sips_config\") || { fuse_limit_critical: 120 };\n\nconst FUSE_SIZE = 20;\nconst TAU = 200;\nconst DT = 1.0;\n\nfunction calc(old_temp, current_amps) {\n    let load_ratio = current_amps / FUSE_SIZE;\n    let target_temp = load_ratio * load_ratio * 100;\n    let alpha = 1 - Math.exp(-DT / TAU);\n    return old_temp + alpha * (target_temp - old_temp);\n}\n\nif (!sips.fuse) sips.fuse = { l1: 0, l2: 0, l3: 0, max: 0 };\n\nsips.fuse.l1 = calc(sips.fuse.l1, sips.grid.l1);\nsips.fuse.l2 = calc(sips.fuse.l2, sips.grid.l2);\nsips.fuse.l3 = calc(sips.fuse.l3, sips.grid.l3);\n\n// SKYDDSLOGIK: Direkt detektion av extrem överlast (>50A)\nlet max_current_real = Math.max(sips.grid.l1, sips.grid.l2, sips.grid.l3);\n\nif (max_current_real > (FUSE_SIZE * 2.5)) {\n    // Instant Protection: Sätt temp till något som garanterat triggar Critical\n    let panicTemp = (config.fuse_limit_critical || 120) + 5;\n    sips.fuse.max = Math.max(sips.fuse.l1, sips.fuse.l2, sips.fuse.l3, panicTemp);\n} else {\n    sips.fuse.max = Math.max(sips.fuse.l1, sips.fuse.l2, sips.fuse.l3);\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 760,
        "y": 60,
        "wires": [
            [
                "e83459563e16abdb"
            ]
        ]
    },
    {
        "id": "e83459563e16abdb",
        "type": "function",
        "z": "3eed00b8c7a9ef73",
        "g": "cf8bf0b14e7e4aa4",
        "name": "MODEL: House",
        "func": "// Termisk modell för huset\nlet sips = msg.sips;\nlet now = Date.now();\n\nif (!sips.sim) sips.sim = { temp: 21.0, lastUpdate: now };\n\nlet dt = (now - sips.sim.lastUpdate) / 3600000.0;\nif (dt > 1) dt = 1;\n\nif (sips.loads.rad.status === \"on\") {\n    sips.sim.temp += (3.0 * dt);\n    if (sips.sim.temp > 21) sips.sim.temp = 21;\n} else {\n    sips.sim.temp -= (2.0 * dt);\n    if (sips.sim.temp < 16) sips.sim.temp = 16;\n}\nsips.sim.lastUpdate = now;\n\n// Prio-logik för elementen\nsips.loads.rad.prio = (sips.sim.temp < 19.0) ? 99 : 3;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1000,
        "y": 60,
        "wires": [
            [
                "3de6acad5750e825"
            ]
        ]
    },
    {
        "id": "3de6acad5750e825",
        "type": "function",
        "z": "3eed00b8c7a9ef73",
        "g": "cf8bf0b14e7e4aa4",
        "name": "RESOURCE MANAGER V12.1",
        "func": "// RESOURCE MANAGER V12.9 (Strict Go-e Logic)\n// SIPS Architect: Hardware Truth overrides API\n\nlet sips = msg.sips;\nsips.resources = sips.resources || {};\n\n// --- 1. DEFINIERA FAS-KONFIGURATION ---\nlet activePhases = [1, 2, 3]; // Ändra till [1] om du bara kör enfas\nlet minAmps = 6;\nlet calculatedMinPower = minAmps * 230 * activePhases.length;\n\n// --- 2. HÄMTA HÅRDVARUSTATUS (STRICT GO-E) ---\n// Vi litar INTE på Teslamate för anslutningsstatus.\nlet goe = sips.goe || { car: 1 };\nlet isConnected = (goe.car > 1); // 1 = Idle/Disconnected\n\n// --- 3. SANITIZATION (Tvätta bort spök-data) ---\n// Om kabeln är ur, så KAN bilen omöjligt ladda. \n// Vi skriver över eventuellt laggande API-data här.\nif (!isConnected) {\n    sips.tesla.charging_state = \"Disconnected\";\n    sips.tesla.actual_amps = 0;\n    // Vi rör inte batterinivån, den kan vara korrekt ändå.\n}\n\n// --- 4. BYGG RESURS-OBJEKTET ---\nlet teslaRes = {\n    id: \"tesla\",\n    type: \"controllable_load\",\n    priority: 15,\n    min_power: calculatedMinPower, \n    phases: activePhases,\n    available: false, // Default\n    reason: \"Initializing\"\n};\n\nif (isConnected) {\n    teslaRes.available = true;\n\n    // Sätt tydlig orsak baserat på Go-e status\n    // 2: Charging, 3: Wait, 4: Finish\n    if (goe.car === 2) teslaRes.reason = \"Charging (Go-e Active)\";\n    else if (goe.car === 3) teslaRes.reason = \"Waiting (Car/Box)\";\n    else if (goe.car === 4) teslaRes.reason = \"Connected (Idle/Complete)\";\n    else teslaRes.reason = \"Ready\";\n\n} else {\n    // Status 1: Ingen kabel\n    teslaRes.available = false;\n    teslaRes.reason = \"Disconnected (Cable Unplugged)\";\n}\n\nsips.resources.tesla = teslaRes;\n\n// --- 5. ÖVRIGA LASTER ---\nlet vvbPrio = sips.loads.vvb.prio !== undefined ? sips.loads.vvb.prio : 50;\nlet radPrio = sips.loads.rad.prio !== undefined ? sips.loads.rad.prio : 30;\nlet avfPrio = sips.loads.avf.prio !== undefined ? sips.loads.avf.prio : 10;\n\nsips.resources.vvb = { id: \"vvb\", available: true, priority: vvbPrio };\nsips.resources.rad = { id: \"rad\", available: true, priority: radPrio };\nsips.resources.avf = { id: \"avf\", available: true, priority: avfPrio };\n\nflow.set(\"sips_state\", sips);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 990,
        "y": 120,
        "wires": [
            [
                "a820781f81b641a5",
                "73886911443170ec"
            ]
        ]
    },
    {
        "id": "a820781f81b641a5",
        "type": "function",
        "z": "3eed00b8c7a9ef73",
        "g": "cf8bf0b14e7e4aa4",
        "name": "STRATEGY V13.5",
        "func": "// STRATEGY V13.7 (No Panic Mode - Full Code)\n// SIPS Architect Verified: Safe Logic Merger\n\nlet sips = msg.sips;\nlet plan = [];\n\n// --- HÄMTA CONFIG ---\nlet config = flow.get(\"sips_config\");\nif (!config || !config.prio) {\n    node.error(\"Config missing! Run INIT.\");\n    return null;\n}\n\n// Hämta Overrides & Historik\nlet overrides = flow.get(\"sips_overrides\") || {};\nsips.history = sips.history || {};\nlet now = Date.now();\n\n// --- SKYDDSPARAMETRAR ---\nconst MIN_OFF_MS = (config.protection ? config.protection.min_off_minutes : 10) * 60000;\nconst EV_REG_MS = (config.protection ? config.protection.ev_regulation_sec : 30) * 1000;\n\n// Hämta last-data\nlet lConf = config.loads_config || {\n    vvb: { watts: 3000, phases: [1, 2, 3] },\n    rad: { watts: 3500, phases: [1, 2, 3] },\n    avf: { watts: 500, phases: [1] }\n};\n\nconst VVB_EST_WATTS = lConf.vvb.watts;\nconst RAD_EST_WATTS = lConf.rad.watts;\nconst AVF_EST_WATTS = lConf.avf.watts;\n\n// --- 1. TID & MODE ---\nlet month = new Date().getMonth() + 1;\nlet hour = new Date().getHours();\nlet isWinter = (month === 12 || month <= 2);\nlet isHighLoadTime = (hour >= 6 && hour < 21);\nlet isGhostMode = isWinter && isHighLoadTime;\nlet targetKw = isGhostMode ? config.target_ghost : config.target_normal;\n\n// --- 2. BUDGET & MÄTVÄRDEN ---\nlet usedKwh = sips.grid.energy_used_hour || 0;\nlet minutesPassed = Math.max(sips.grid.minutes_passed || 1, 1);\nlet kwhLeft = targetKw - usedKwh;\n// Räkna ut max effekt för resten av timmen\nlet maxAllowedPowerKw = (kwhLeft / ((60 - minutesPassed) / 60.0)) - 0.5;\nmaxAllowedPowerKw = Math.max(Math.min(maxAllowedPowerKw, 13.5), 0);\nconst POWER_LIMIT = maxAllowedPowerKw * 1000;\nlet totalPower = sips.grid.power;\n\nsips.log = { limit: POWER_LIMIT, target: targetKw, used: usedKwh, ghost: isGhostMode ? 1 : 0 };\n\n// --- 3. PRIORITERING (Uppdaterad: Ingen Panic Mode) ---\nlet rTesla = sips.resources.tesla;\nlet rVvb = sips.resources.vvb;\nlet rRad = sips.resources.rad;\nlet rAvf = sips.resources.avf;\nlet houseTemp = sips.sim ? sips.sim.temp : 21.0;\n\n// A. Grundprioritering\nif (isGhostMode) {\n    let p = config.prio.ghost;\n    let limits = config.temp_limits || { critical: 19.0, cold: 20.0 };\n    \n    // Värme-logik\n    if (houseTemp < limits.critical) rRad.priority = p.rad_critical;\n    else if (houseTemp < limits.cold) rRad.priority = p.rad_cold;\n    else rRad.priority = p.rad_warm;\n\n    rAvf.priority = p.avf; \n    rVvb.priority = p.vvb;\n    // Bilen får alltid normal prio i Ghost Mode (oftast låg/0)\n    rTesla.priority = p.tesla_normal; \n} else {\n    let p = config.prio.normal;\n    rRad.priority = p.rad; \n    rAvf.priority = p.avf;\n    rVvb.priority = p.vvb_prio;\n    // Bilen får alltid normal prio (ingen panic check)\n    rTesla.priority = p.tesla_normal; \n}\n\n// B. Dynamisk EV-Prioritet (Förhindra jojo-laddning)\n// Om vi redan laddar med bra fart, behåll prio för att inte bli avbruten av småsaker\nif (sips.tesla.amps > config.tesla_min) rTesla.priority = 40;\nelse rTesla.priority = 90; // Annars läggs den sist\n\n// C. Override-Prioritering\nif (overrides.rad_until > now) rRad.priority = 200;\nif (overrides.vvb_until > now) rVvb.priority = 200;\nif (overrides.car_until > now) rTesla.priority = 200;\n\n// Sätt ihop resurslistan\nlet teslaPhases = config.tesla_phases || [1];\n\nlet resources = [\n    { ...rTesla, active: (sips.tesla.charging_state === \"Charging\" || sips.tesla.actual_amps > 1), type: \"dynamic\", phases: teslaPhases },\n    { ...rVvb, active: (sips.loads.vvb.status === \"on\"), type: \"binary\", watts: VVB_EST_WATTS, phases: lConf.vvb.phases },\n    { ...rRad, active: (sips.loads.rad.status === \"on\"), type: \"binary\", watts: RAD_EST_WATTS, phases: lConf.rad.phases },\n    { ...rAvf, active: (sips.loads.avf.status === \"on\"), type: \"binary\", watts: AVF_EST_WATTS, phases: lConf.avf.phases }\n];\nresources.sort((a, b) => a.priority - b.priority);\n\n// --- 4. ACTION LOGIC (MOTORN) ---\nlet shedMode = false;\nlet statusText = `${isGhostMode ? \"GHOST\" : \"LOW\"} (${targetKw}kW) `;\n\nif (overrides.rad_until > now) statusText = \"BOOST RAD\";\nif (overrides.vvb_until > now) statusText = \"BOOST VVB\";\n\n// A. FORCE OFF (Negativ prio = Stäng av)\nresources.forEach(r => {\n    if (r.priority < 0 && r.active) {\n        plan.push({ id: r.id, action: r.type === \"dynamic\" ? \"stop\" : \"off\" });\n        sips.history[r.id].lastStop = now;\n    }\n});\n\n// B. SHEDDING (Minska last om vi går över gränsen)\nlet overloadL1 = sips.fuse.l1 > config.fuse_limit_warning;\nlet overloadL2 = sips.fuse.l2 > config.fuse_limit_warning;\nlet overloadL3 = sips.fuse.l3 > config.fuse_limit_warning;\nlet totalOverload = totalPower > POWER_LIMIT;\n\nif (totalOverload || overloadL1 || overloadL2 || overloadL3) {\n    shedMode = true;\n    let reductionNeeded = 0;\n    let isCritical = sips.fuse.max > config.fuse_limit_critical;\n\n    if (isCritical) {\n        reductionNeeded = 99000; statusText = \"CRITICAL PANIC\";\n    } else {\n        reductionNeeded = Math.max(totalPower - POWER_LIMIT, 2000);\n    }\n\n    // Loopa resurser från lägst prio -> högst\n    for (let r of resources) {\n        if (!r.active) continue;\n        if (r.priority >= 200) continue; // Rör inte overrides\n\n        let contributesToProblem = false;\n        if (totalOverload) contributesToProblem = true;\n        else {\n            // Fas-koll: Påverkar denna last den överbelastade fasen?\n            let hitsL1 = overloadL1 && r.phases.includes(1);\n            let hitsL2 = overloadL2 && r.phases.includes(2);\n            let hitsL3 = overloadL3 && r.phases.includes(3);\n            if (hitsL1 || hitsL2 || hitsL3) contributesToProblem = true;\n        }\n\n        if (!contributesToProblem) continue;\n\n        if (r.type === \"dynamic\") {\n            // --- EV REGLERING ---\n            if (!r.available) continue;\n\n            // Fysik-kalkyl: Hur många watt är 1 Ampere?\n            let rPhaseCount = (r.phases && r.phases.length > 0) ? r.phases.length : 1;\n            let wattsPerAmp = 230 * rPhaseCount; \n\n            // SOFT LANDING (Undvik att reglera för ofta om det inte är kritiskt)\n            if (!isCritical && (now - sips.history[r.id].lastRegulate < EV_REG_MS)) continue;\n\n            let ampsToReduce = Math.ceil(reductionNeeded / wattsPerAmp);\n            if (ampsToReduce < 1) ampsToReduce = 1;\n            \n            let newAmps = sips.tesla.amps - ampsToReduce;\n\n            if (newAmps < config.tesla_min) {\n                // Måste stänga av helt\n                plan.push({ id: r.id, action: \"stop\" });\n                reductionNeeded -= (sips.tesla.amps * wattsPerAmp);\n                sips.history[r.id].lastStop = now;\n                break; // Gå till nästa last (eller klar)\n            } else {\n                // Reglera ner\n                plan.push({ id: r.id, action: \"set\", value: newAmps });\n                sips.history[r.id].lastRegulate = now;\n                reductionNeeded = 0; // Vi är nöjda\n            }\n        } else {\n            // --- BINÄR LAST (AV/PÅ) ---\n            plan.push({ id: r.id, action: \"off\" });\n            sips.history[r.id].lastStop = now;\n            break; // En stor last räcker oftast\n        }\n        if (reductionNeeded <= 0) break;\n    }\n}\n// C. RECOVERY (Öka last om det finns plats)\nelse {\n    let coolDownDrop = config.fuse_hysteresis_temp || 5;\n    let coolDownLimit = (config.fuse_limit_warning || 110) - coolDownDrop;\n\n    if (sips.fuse.max > coolDownLimit) {\n        statusText = `COOLING (${Math.round(sips.fuse.max)}°C > ${coolDownLimit})`;\n    }\n    else {\n        let wattsAvailable = POWER_LIMIT - totalPower;\n        // Sortera om: Högst prio först!\n        let startOrder = [...resources].sort((a, b) => b.priority - a.priority);\n        let actionTaken = false;\n\n        for (let r of startOrder) {\n            if (actionTaken && r.type === \"binary\") continue; // Bara en binär start åt gången\n            if (r.priority < 0 || r.active) continue;\n\n            let lastStop = sips.history[r.id] ? sips.history[r.id].lastStop : 0;\n            if ((now - lastStop) < MIN_OFF_MS) continue; // Kortslutningsskydd\n\n            if (r.type === \"binary\") {\n                let requiredBuffer = config.hysteresis_buffer || 1200;\n                if (wattsAvailable > (r.watts + requiredBuffer) && r.available) {\n                    plan.push({ id: r.id, action: \"on\" });\n                    sips.history[r.id].lastStart = now;\n                    wattsAvailable -= r.watts;\n                    actionTaken = true;\n                }\n            }\n            else if (r.id === \"tesla\" && r.available) {\n                // Starta EV\n                let rPhaseCount = (r.phases && r.phases.length > 0) ? r.phases.length : 1;\n                let startWatts = (config.tesla_min * 230 * rPhaseCount); \n                let req = startWatts + config.safety_margin;\n\n                if (wattsAvailable > req) {\n                    plan.push({ id: \"tesla\", action: \"start\" });\n                    plan.push({ id: \"tesla\", action: \"set\", value: config.tesla_min });\n                    sips.history[r.id].lastStart = now;\n                    sips.tesla.amps = config.tesla_min;\n                    wattsAvailable -= startWatts;\n                }\n            }\n        }\n\n        // Smart Turbo (Reglera upp EV om den redan är igång)\n        let car = resources.find(r => r.id === \"tesla\");\n        if (car && car.active && car.available && wattsAvailable > config.hysteresis_buffer) {\n            if (now - sips.history[car.id].lastRegulate > EV_REG_MS) {\n                \n                // Räkna korrekt på faser\n                let carPhaseCount = (car.phases && car.phases.length > 0) ? car.phases.length : 1;\n                let wattsPerAmp = 230 * carPhaseCount;\n\n                let minStep = config.tesla_step_min !== undefined ? config.tesla_step_min : 1;\n                let distToMax = config.tesla_max - sips.tesla.amps;\n                \n                // Räkna ut headroom\n                let headroomAmps = Math.floor((wattsAvailable - config.safety_margin) / wattsPerAmp);\n                \n                // SÄKERHET: Vid 3-fas, ta bara 90% av utrymmet\n                if (carPhaseCount > 1) headroomAmps = Math.floor(headroomAmps * 0.9);\n\n                let requiredHeadroom = (distToMax < minStep) ? 1 : minStep;\n\n                if (headroomAmps >= requiredHeadroom) {\n                    let step = Math.max(requiredHeadroom, Math.floor(headroomAmps / 2)); \n                    let newAmps = Math.min(sips.tesla.amps + step, config.tesla_max);\n                    \n                    if (newAmps > sips.tesla.amps) {\n                        plan.push({ id: \"tesla\", action: \"set\", value: newAmps });\n                        sips.history[car.id].lastRegulate = now;\n                    }\n                }\n            }\n        }\n    }\n}\n\n// Logga API count om vi rör bilen\nif (plan.find(p => p.id === \"tesla\")) sips.api.count++;\n\n// System State för Routern\nlet sysState = \"normal\";\nif (sips.fuse.max > config.fuse_limit_critical) sysState = \"critical\";\nelse if (shedMode || sips.fuse.max > config.fuse_limit_warning) sysState = \"warning\";\nelse if (resources.some(r => r.priority > 0 && !r.active && r.available)) sysState = \"recovery\";\n\nflow.set(\"sips_state\", sips);\nmsg.plan = plan;\nmsg.systemState = sysState;\nnode.status({ fill: sysState === \"normal\" ? \"green\" : sysState === \"warning\" ? \"orange\" : \"red\", shape: \"dot\", text: statusText });\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1130,
        "y": 180,
        "wires": [
            [
                "465db2ea43b9bb53",
                "cd97a78245ed03b5",
                "9cc697e5e2f1d6b3"
            ]
        ]
    },
    {
        "id": "a52beea9e11f07c7",
        "type": "function",
        "z": "3eed00b8c7a9ef73",
        "g": "cf8bf0b14e7e4aa4",
        "name": "Uppdatera INIT (V12.8)",
        "func": "// INIT V14.0 - Centralized Logging Config\nlet config = {\n    // --- TARIFF & BUDGET ---\n    target_ghost: 7.0,\n    target_normal: 11.0,\n\n    // --- SÄKRINGSSKYDD ---\n    fuse_limit_warning: 110,\n    fuse_limit_critical: 120,\n    fuse_hysteresis_temp: 5, \n\n    // --- LOGGING & RBE (NYHET) ---\n    logging: {\n        heartbeat_minutes: 5,  // Tvinga logg om inget hänt på X min\n        threshold_amps: 0.2,    // Ignorera ändringar mindre än X Ampere\n        threshold_watts: 0     // (Optionell) Om vi vill ha filter på effekt\n    },\n\n    // --- TESLA ---\n    tesla_min: 6,\n    tesla_max: 16,\n    tesla_phases: [1,2,3],\n\n    // --- SKYDDSMEKANISMER ---\n    protection: {\n        min_off_minutes: 10,      \n        ev_regulation_sec: 30     \n    },\n\n    // --- REGLERING ---\n    hysteresis_buffer: 1200, \n    safety_margin: 800,      \n    tesla_step_min: 1,       \n    router_retry_ms: 60000,\n\n    // --- LAST-DEFINITIONER ---\n    loads_config: {\n        vvb: { watts: 3000, phases: [2,3] }, \n        rad: { watts: 3500, phases: [2,3] }, \n        avf: { watts: 500,  phases: [1] }\n    },\n\n    // --- TEMP GRÄNSER ---\n    temp_limits: { critical: 19.0, cold: 21.0 },\n\n    // --- PRIORITERING ---\n    prio: {\n        ghost: { rad_critical: 100, rad_cold: 60, rad_warm: 20, vvb: 50, tesla_panic: 50, tesla_normal: 0, avf: -1 },\n        normal: { rad: 60, vvb_prio: 55, vvb_yield: 55, tesla_panic: 95, tesla_normal: 90, avf: 50 }\n    }\n};\n\n// 1. Spara config\nflow.set(\"sips_config\", config);\n\n// 2. Hantera State\nlet state = flow.get(\"sips_state\");\n\nif (!state) {\n    state = {\n        tesla: { amps: 0, actual_amps: 0, state: \"unknown\", max_amps_dynamic: config.tesla_max },\n        loads: {}, grid: {}, fuse: {}, sim: {}, api: { count: 0 }, history: {}\n    };\n}\n\n// Synkronisera laster\nif (!state.loads) state.loads = {};\nif (!state.history) state.history = {};\nfor (let key in config.loads_config) {\n    if (!state.loads[key]) state.loads[key] = { status: \"off\", prio: 50 };\n    if (!state.history[key]) state.history[key] = { lastStop: 0, lastStart: 0 };\n    state.loads[key].phases = config.loads_config[key].phases;\n    state.loads[key].watts = config.loads_config[key].watts;\n}\n\nflow.set(\"sips_state\", state);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 910,
        "y": 240,
        "wires": [
            []
        ]
    },
    {
        "id": "24bbf6da4dc3bccc",
        "type": "inject",
        "z": "3eed00b8c7a9ef73",
        "g": "cf8bf0b14e7e4aa4",
        "name": "MANUAL INIT",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 680,
        "y": 200,
        "wires": [
            [
                "a52beea9e11f07c7"
            ]
        ]
    },
    {
        "id": "a8726aa5f03d58ef",
        "type": "inject",
        "z": "3eed00b8c7a9ef73",
        "g": "cf8bf0b14e7e4aa4",
        "name": "Startup",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "x": 660,
        "y": 240,
        "wires": [
            [
                "a52beea9e11f07c7"
            ]
        ]
    },
    {
        "id": "465db2ea43b9bb53",
        "type": "function",
        "z": "3eed00b8c7a9ef73",
        "g": "5192e703de6729fe",
        "name": "ROUTER (V12.8)",
        "func": "// ROUTER V12.10 (Hybrid Key Fix)\n// SIPS Architect: Fixes binary toggle bug introduced in V12.9\n\nlet plan = msg.plan;\nlet sips = flow.get(\"sips_state\");\nlet config = flow.get(\"sips_config\") || {}; \n\nconst COMMAND_TTL = config.router_retry_ms || 60000;\n\n// Hämta Router-minne\nlet routerStore = context.get(\"routerStore\") || { \n    lastState: \"\", \n    lastTs: 0,\n    devices: {} \n};\n\nlet now = Date.now();\nlet mqttMsgs = [];\n\n// --- 1. STATUS RBE ---\nlet sendStatus = false;\nif (msg.systemState !== routerStore.lastState) sendStatus = true;\nelse if ((now - routerStore.lastTs) > 300000) sendStatus = true;\n\nlet statusMsg = null;\nif (sendStatus) {\n    statusMsg = { topic: \"homey/system/state\", payload: msg.systemState, qos: 1 };\n    routerStore.lastState = msg.systemState;\n    routerStore.lastTs = now;\n}\n\n// --- 2. KOMMANDO HANTERING ---\nif (plan) {\n    // Sortera: Set före Start\n    plan.sort((a,b) => {\n        const order = { \"set\": 1, \"start\": 2, \"stop\": 3, \"off\": 4, \"on\": 5 };\n        return (order[a.action] || 99) - (order[b.action] || 99);\n    });\n\n    plan.forEach(cmd => {\n        // Fysik-spärr för Tesla\n        if (cmd.id === \"tesla\") {\n             if (!sips.goe || sips.goe.car <= 1) return; \n        }\n\n        let cmdValue = cmd.value !== undefined ? cmd.value : \"\";\n        let cmdSignature = `${cmd.action}_${cmdValue}`;\n        \n        // --- NYCKEL-LOGIK (FIXEN) ---\n        let historyKey = \"\";\n        \n        if (cmd.id === \"tesla\") {\n            // För Tesla: Separera nycklar för att kunna köra Start+Set samtidigt\n            historyKey = `${cmd.id}_${cmd.action}`; \n        } else {\n            // För Shelly (Binär): Använd BARA ID. \n            // Då kommer \"off\" att skriva över \"on\" i minnet, vilket tvingar fram en sändning.\n            historyKey = cmd.id; \n        }\n        \n        let lastEntry = routerStore.devices[historyKey] || { cmd: \"\", ts: 0 };\n\n        // RBE + TTL Check\n        if (lastEntry.cmd !== cmdSignature || (now - lastEntry.ts) > COMMAND_TTL) {\n            \n            routerStore.devices[historyKey] = { cmd: cmdSignature, ts: now };\n\n            if (cmd.id === \"tesla\") {\n                if (cmd.action === \"set\") mqttMsgs.push({ topic: \"EV-Charger/1/amp/set\", payload: cmd.value.toString(), qos: 1 });\n                if (cmd.action === \"start\") mqttMsgs.push({ topic: \"EV-Charger/1/frc/set\", payload: \"0\", qos: 1 });\n                if (cmd.action === \"stop\") mqttMsgs.push({ topic: \"EV-Charger/1/frc/set\", payload: \"1\", qos: 1 });\n            } else {\n                let topic = \"\";\n                if (cmd.id === \"vvb\") topic = \"shellies/vvb1/relay/0/command\";\n                if (cmd.id === \"rad\") topic = \"shellies/rad1/relay/0/command\";\n                if (cmd.id === \"avf\") topic = \"shellies/avf1/relay/0/command\";\n                if (topic) mqttMsgs.push({ topic: topic, payload: cmd.action, qos: 1 });\n            }\n        }\n    });\n}\n\ncontext.set(\"routerStore\", routerStore);\n\n// Output\nlet storageMsg = null;\nlet teslaActive = mqttMsgs.some(m => m.topic.includes(\"EV-Charger\"));\nif (teslaActive) {\n    storageMsg = { topic: \"system/sips/storage\", payload: JSON.stringify({c: sips.api.count, m: sips.api.month}), retain: true, qos: 1 };\n}\n\nlet misc = [];\nif (statusMsg) misc.push(statusMsg);\nif (storageMsg) misc.push(storageMsg);\n\nif (mqttMsgs.length === 0 && misc.length === 0) return null;\nreturn [mqttMsgs, null, misc];",
        "outputs": 3,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1530,
        "y": 120,
        "wires": [
            [
                "86691c8d33a02da5"
            ],
            [
                "fa8fa39964d2d08e",
                "f2183dc2955be820"
            ],
            [
                "fa8fa39964d2d08e",
                "f2183dc2955be820"
            ]
        ]
    },
    {
        "id": "86691c8d33a02da5",
        "type": "delay",
        "z": "3eed00b8c7a9ef73",
        "g": "5192e703de6729fe",
        "name": "Tesla Rate Limit",
        "pauseType": "rate",
        "timeout": "5",
        "timeoutUnits": "seconds",
        "rate": "4",
        "nbRateUnits": "1",
        "rateUnits": "minute",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1940,
        "y": 100,
        "wires": [
            [
                "fa8fa39964d2d08e",
                "f2183dc2955be820"
            ]
        ]
    },
    {
        "id": "fa8fa39964d2d08e",
        "type": "mqtt out",
        "z": "3eed00b8c7a9ef73",
        "g": "5192e703de6729fe",
        "name": "MQTT OUT",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "fa6a33cd942a9c83",
        "x": 2130,
        "y": 160,
        "wires": []
    },
    {
        "id": "f2183dc2955be820",
        "type": "debug",
        "z": "3eed00b8c7a9ef73",
        "g": "5192e703de6729fe",
        "name": "Router Debug",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 2120,
        "y": 220,
        "wires": []
    },
    {
        "id": "0e5b7cfa1c0ca96c",
        "type": "influxdb out",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "influxdb": "8d24e520361b7e2c",
        "name": "VVB",
        "measurement": "homey/logic/vvb",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 2090,
        "y": 660,
        "wires": []
    },
    {
        "id": "5e6e102b39c894df",
        "type": "influxdb out",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "influxdb": "8d24e520361b7e2c",
        "name": "Radiators",
        "measurement": "homey/logic/radiators",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 2100,
        "y": 700,
        "wires": []
    },
    {
        "id": "6c022f6774a4cc71",
        "type": "influxdb out",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "influxdb": "8d24e520361b7e2c",
        "name": "Avfuktare",
        "measurement": "homey/logic/avf",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 2100,
        "y": 740,
        "wires": []
    },
    {
        "id": "6977b02bb44346ff",
        "type": "influxdb out",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "influxdb": "8d24e520361b7e2c",
        "name": "Tesla Req",
        "measurement": "tesla/charge/current/request",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 2100,
        "y": 780,
        "wires": []
    },
    {
        "id": "50168a41b8f03124",
        "type": "influxdb out",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "influxdb": "8d24e520361b7e2c",
        "name": "Fuse L1",
        "measurement": "fuse_temp_L1",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 2100,
        "y": 820,
        "wires": []
    },
    {
        "id": "06b187955acb7b86",
        "type": "influxdb out",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "influxdb": "8d24e520361b7e2c",
        "name": "Fuse L2",
        "measurement": "fuse_temp_L2",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 2100,
        "y": 860,
        "wires": []
    },
    {
        "id": "63ca7cd6919362ff",
        "type": "influxdb out",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "influxdb": "8d24e520361b7e2c",
        "name": "Fuse L3",
        "measurement": "fuse_temp_L3",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 2100,
        "y": 900,
        "wires": []
    },
    {
        "id": "0fddf1d214b7d01d",
        "type": "influxdb out",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "influxdb": "8d24e520361b7e2c",
        "name": "Tesla Max",
        "measurement": "tesla/charge_current_request_max",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 2100,
        "y": 940,
        "wires": []
    },
    {
        "id": "f4994743ff5ad18b",
        "type": "influxdb out",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "influxdb": "8d24e520361b7e2c",
        "name": "API Count",
        "measurement": "tesla/control_counter",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 2110,
        "y": 980,
        "wires": []
    },
    {
        "id": "d73df6f2d0a9ded5",
        "type": "function",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "name": "Extract Total_Power",
        "func": "// Extract power from grid JSON\nlet data = msg.payload;\nif (typeof data === \"string\") try { data = JSON.parse(data); } catch(e) {}\nif (data.metrics && data.metrics.Power_Total !== undefined) {\n    return { payload: parseFloat(data.metrics.Power_Total) };\n}\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1140,
        "y": 580,
        "wires": [
            [
                "2a2cdbd33c3741bf"
            ]
        ]
    },
    {
        "id": "2a2cdbd33c3741bf",
        "type": "influxdb out",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "influxdb": "8d24e520361b7e2c",
        "name": "shelly/3em/123/power",
        "measurement": "RPI_shelly/3em/123/power",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 1440,
        "y": 560,
        "wires": []
    },
    {
        "id": "eeb2e66b55d708c4",
        "type": "influxdb out",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "influxdb": "8d24e520361b7e2c",
        "name": "shelly/3em/0/current",
        "measurement": "RPI_shelly/3em/0/current",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 1440,
        "y": 600,
        "wires": []
    },
    {
        "id": "57687425891251a8",
        "type": "influxdb out",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "influxdb": "8d24e520361b7e2c",
        "name": "shelly/3em/1/current",
        "measurement": "RPI_shelly/3em/1/current",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 1440,
        "y": 640,
        "wires": []
    },
    {
        "id": "88d2c26357c74df6",
        "type": "influxdb out",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "influxdb": "8d24e520361b7e2c",
        "name": "shelly/3em/2/current",
        "measurement": "RPI_shelly/3em/2/current",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 1440,
        "y": 680,
        "wires": []
    },
    {
        "id": "f32dacf6932d3251",
        "type": "function",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "name": "Extract Currents",
        "func": "let data = msg.payload;\nif (typeof data === \"string\") try { data = JSON.parse(data); } catch(e) {}\nif (!data.metrics) return null;\n\nfunction get(val) { return { payload: parseFloat(val) }; }\nreturn [get(data.metrics.Current_L1), get(data.metrics.Current_L2), get(data.metrics.Current_L3)];",
        "outputs": 3,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1120,
        "y": 640,
        "wires": [
            [
                "eeb2e66b55d708c4"
            ],
            [
                "57687425891251a8"
            ],
            [
                "88d2c26357c74df6"
            ]
        ]
    },
    {
        "id": "70af6cc2a74a0b8c",
        "type": "function",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "name": "Extract Power",
        "func": "let data = msg.payload;\nif (typeof data === \"string\") try { data = JSON.parse(data); } catch(e) {}\nif (!data.metrics) return null;\n\nfunction get(val) { return { payload: parseFloat(val) }; }\nreturn [get(data.metrics.Power_L1), get(data.metrics.Power_L2), get(data.metrics.Power_L3)];",
        "outputs": 3,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1120,
        "y": 740,
        "wires": [
            [
                "13a8b24575162bc0"
            ],
            [
                "611df54fa9d4dae1"
            ],
            [
                "ccb70e46e6a58ebf"
            ]
        ]
    },
    {
        "id": "13a8b24575162bc0",
        "type": "influxdb out",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "influxdb": "8d24e520361b7e2c",
        "name": "shelly/3em/0/power",
        "measurement": "RPI_shelly/3em/0/power",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 1430,
        "y": 720,
        "wires": []
    },
    {
        "id": "611df54fa9d4dae1",
        "type": "influxdb out",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "influxdb": "8d24e520361b7e2c",
        "name": "shelly/3em/1/power",
        "measurement": "RPI_shelly/3em/1/power",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 1430,
        "y": 760,
        "wires": []
    },
    {
        "id": "ccb70e46e6a58ebf",
        "type": "influxdb out",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "influxdb": "8d24e520361b7e2c",
        "name": "shelly/3em/2/power",
        "measurement": "RPI_shelly/3em/2/power",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 1430,
        "y": 800,
        "wires": []
    },
    {
        "id": "3d6eb74669a18ef6",
        "type": "influxdb out",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "influxdb": "8d24e520361b7e2c",
        "name": "tesla/charger_actual_current",
        "measurement": "tesla/charger_actual_current",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 2160,
        "y": 1180,
        "wires": []
    },
    {
        "id": "cd97a78245ed03b5",
        "type": "function",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "name": "Format Influx Data",
        "func": "// FORMAT INFLUX DATA V14.2 (Bugfix: Rename 'process')\n// SIPS Architect: Stops DB spamming using centralized config.\n\nlet sips = msg.sips;\nlet log = sips.log || {};\nlet config = flow.get(\"sips_config\") || {};\n\n// Hämta inställningar från INIT (med fallback)\nlet logConfig = config.logging || { heartbeat_minutes: 60, threshold_amps: 0.2 };\n\nconst HEARTBEAT_MS = (logConfig.heartbeat_minutes * 60 * 1000);\nconst THRESHOLD_AMPS = logConfig.threshold_amps;\n\n// Hämta minne för senaste loggningen\nlet lastLog = context.get(\"lastLog\") || {};\nlet now = Date.now();\n\n// Helper för RBE (Report By Exception) - OMDÖPT FÖR ATT UNDVIKA KONFLIKT\nfunction checkRBE(key, currentValue, isAnalog = false) {\n    // 0. Hantera undefined/null\n    let val = (currentValue === undefined || currentValue === null || isNaN(currentValue)) ? 0 : currentValue;\n\n    // 1. Hämta historik för denna nyckel\n    let history = lastLog[key] || { val: null, ts: 0 };\n\n    // 2. Avgör om vi ska skicka data\n    let send = false;\n\n    if (isAnalog) {\n        // Filtrera brus för analoga värden (t.ex. Ampere, Temp)\n        // Om skillnaden är större än tröskelvärdet -> Skicka\n        if (Math.abs(val - history.val) >= THRESHOLD_AMPS) send = true;\n    } else {\n        // Binära/Heltal: Logga vid minsta ändring\n        if (val !== history.val) send = true;\n    }\n\n    // 3. Heartbeat (Tvinga loggning om det gått lång tid)\n    if ((now - history.ts) > HEARTBEAT_MS) send = true;\n\n    // 4. Utför\n    if (send) {\n        lastLog[key] = { val: val, ts: now }; // Uppdatera minnet\n        return { payload: val };\n    } else {\n        return null; // Skicka inget\n    }\n}\n\n// Data Mapping\nlet vvb = sips.loads.vvb.status === \"on\" ? 1 : 0;\nlet rad = sips.loads.rad.status === \"on\" ? 1 : 0;\nlet avf = sips.loads.avf.status === \"on\" ? 1 : 0;\nlet maxLimit = config.tesla_max || 16;\n\n// Process (Nu använder vi det nya funktionsnamnet)\nlet output = [\n    checkRBE(\"vvb\", vvb),                            // 1\n    checkRBE(\"rad\", rad),                            // 2\n    checkRBE(\"avf\", avf),                            // 3\n    checkRBE(\"tesla_req\", sips.tesla.amps),          // 4\n    checkRBE(\"fuse_l1\", sips.fuse.l1, true),         // 5 (Analog)\n    checkRBE(\"fuse_l2\", sips.fuse.l2, true),         // 6 (Analog)\n    checkRBE(\"fuse_l3\", sips.fuse.l3, true),         // 7 (Analog)\n    checkRBE(\"tesla_max\", maxLimit),                 // 8\n    checkRBE(\"api_cnt\", sips.api.count),             // 9\n    checkRBE(\"limit\", log.limit, true),              // 10 (Analog)\n    checkRBE(\"used\", log.used, true),                // 11 (Analog)\n    checkRBE(\"target\", log.target),                  // 12\n    checkRBE(\"ghost\", log.ghost),                    // 13\n    checkRBE(\"act_amps\", sips.tesla.actual_amps, true), // 14 (Analog)\n    checkRBE(\"force\", sips.goe.frc),                 // 15\n    checkRBE(\"car\", sips.goe.car)                    // 16\n];\n\n// Spara state till nästa gång\ncontext.set(\"lastLog\", lastLog);\n\nreturn output;",
        "outputs": 16,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1750,
        "y": 900,
        "wires": [
            [
                "0e5b7cfa1c0ca96c",
                "499987080eb7c356"
            ],
            [
                "5e6e102b39c894df",
                "08cf75a83c8610ad"
            ],
            [
                "6c022f6774a4cc71",
                "d8f383c26e73f67c"
            ],
            [
                "6977b02bb44346ff",
                "1b4f3371b3397cb9"
            ],
            [
                "50168a41b8f03124",
                "3e6e52e565bdc32e"
            ],
            [
                "06b187955acb7b86",
                "74e0c13822ddd416"
            ],
            [
                "63ca7cd6919362ff",
                "70fcb03927189877"
            ],
            [
                "0fddf1d214b7d01d",
                "2f3061b4a04d50ed"
            ],
            [
                "f4994743ff5ad18b",
                "2c75eb53e54b7f6d"
            ],
            [
                "6c59a443ece883cd",
                "0edd2ed72415efc9"
            ],
            [
                "a247090378a4af0d",
                "fb1667db8e514d0b"
            ],
            [
                "4e3e690d57655ee6",
                "f53d84969b5c6984"
            ],
            [
                "4bca7de47a6d27af",
                "12c3d51f1fec7959"
            ],
            [
                "3d6eb74669a18ef6",
                "3dac916d4c67f1b4"
            ],
            [
                "55f80dab524db438",
                "c7d9301c2825d9e9"
            ],
            [
                "7d9ec10db76f9143",
                "1b90e546f47923db"
            ]
        ]
    },
    {
        "id": "6c59a443ece883cd",
        "type": "influxdb out",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "influxdb": "8d24e520361b7e2c",
        "name": "Limit",
        "measurement": "strategy/power_limit",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 2090,
        "y": 1020,
        "wires": []
    },
    {
        "id": "a247090378a4af0d",
        "type": "influxdb out",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "influxdb": "8d24e520361b7e2c",
        "name": "Used",
        "measurement": "strategy/energy_used",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 2090,
        "y": 1060,
        "wires": []
    },
    {
        "id": "4e3e690d57655ee6",
        "type": "influxdb out",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "influxdb": "8d24e520361b7e2c",
        "name": "Target",
        "measurement": "strategy/energy_target",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 2090,
        "y": 1100,
        "wires": []
    },
    {
        "id": "4bca7de47a6d27af",
        "type": "influxdb out",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "influxdb": "8d24e520361b7e2c",
        "name": "Ghost",
        "measurement": "strategy/ghost_mode",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 2090,
        "y": 1140,
        "wires": []
    },
    {
        "id": "f7bbdfd6d1b3c684",
        "type": "mqtt in",
        "z": "3eed00b8c7a9ef73",
        "g": "993618586782759e",
        "name": "IN: EV-Status",
        "topic": "EV-Charger/1/car",
        "qos": "1",
        "datatype": "auto-detect",
        "broker": "fa6a33cd942a9c83",
        "nl": false,
        "rap": false,
        "inputs": 0,
        "x": 70,
        "y": 560,
        "wires": [
            [
                "7bb95e948d7e50a1"
            ]
        ]
    },
    {
        "id": "73886911443170ec",
        "type": "debug",
        "z": "3eed00b8c7a9ef73",
        "g": "cf8bf0b14e7e4aa4",
        "name": "Debug - Resource mgmt.",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1310,
        "y": 40,
        "wires": []
    },
    {
        "id": "3dac916d4c67f1b4",
        "type": "debug",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "name": "LOG: charger_actual_current",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2420,
        "y": 1180,
        "wires": []
    },
    {
        "id": "55f80dab524db438",
        "type": "influxdb out",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "influxdb": "8d24e520361b7e2c",
        "name": "goe/force_state",
        "measurement": "goe/force_state",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 2120,
        "y": 1220,
        "wires": []
    },
    {
        "id": "7d9ec10db76f9143",
        "type": "influxdb out",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "influxdb": "8d24e520361b7e2c",
        "name": "goe/car_status",
        "measurement": "goe/car_status",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 2120,
        "y": 1260,
        "wires": []
    },
    {
        "id": "c7d9301c2825d9e9",
        "type": "debug",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "name": "LOG: force_state",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2390,
        "y": 1220,
        "wires": []
    },
    {
        "id": "1b90e546f47923db",
        "type": "debug",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "name": "LOG: Car_Status",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2390,
        "y": 1260,
        "wires": []
    },
    {
        "id": "12c3d51f1fec7959",
        "type": "debug",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "name": "LOG: Goast",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2370,
        "y": 1140,
        "wires": []
    },
    {
        "id": "f53d84969b5c6984",
        "type": "debug",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "name": "LOG: Target",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2370,
        "y": 1100,
        "wires": []
    },
    {
        "id": "fb1667db8e514d0b",
        "type": "debug",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "name": "LOG: used",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2370,
        "y": 1060,
        "wires": []
    },
    {
        "id": "0edd2ed72415efc9",
        "type": "debug",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "name": "LOG: Limit",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2370,
        "y": 1020,
        "wires": []
    },
    {
        "id": "2c75eb53e54b7f6d",
        "type": "debug",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "name": "LOG: API_count",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2380,
        "y": 980,
        "wires": []
    },
    {
        "id": "2f3061b4a04d50ed",
        "type": "debug",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "name": "LOG: Tesla Max",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2380,
        "y": 940,
        "wires": []
    },
    {
        "id": "70fcb03927189877",
        "type": "debug",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "name": "LOG: Fuse L3",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2380,
        "y": 900,
        "wires": []
    },
    {
        "id": "74e0c13822ddd416",
        "type": "debug",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "name": "LOG: Fuse L2",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2380,
        "y": 860,
        "wires": []
    },
    {
        "id": "3e6e52e565bdc32e",
        "type": "debug",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "name": "LOG: Fuse L1",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2380,
        "y": 820,
        "wires": []
    },
    {
        "id": "1b4f3371b3397cb9",
        "type": "debug",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "name": "LOG: Tesla Req",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2380,
        "y": 780,
        "wires": []
    },
    {
        "id": "08cf75a83c8610ad",
        "type": "debug",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "name": "LOG: Rad",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2360,
        "y": 700,
        "wires": []
    },
    {
        "id": "d8f383c26e73f67c",
        "type": "debug",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "name": "LOG: Avfuktare",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2380,
        "y": 740,
        "wires": []
    },
    {
        "id": "499987080eb7c356",
        "type": "debug",
        "z": "3eed00b8c7a9ef73",
        "g": "d4250ce404ec61b6",
        "name": "LOG:VVB",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2360,
        "y": 660,
        "wires": []
    },
    {
        "id": "96020529de5cd660",
        "type": "function",
        "z": "3eed00b8c7a9ef73",
        "d": true,
        "name": "Uppdatera INIT (V12.8)",
        "func": "// INIT V13.3 - Cycle Protection & Configurable Regulation\nlet config = {\n    // --- TARIFF & BUDGET ---\n    target_ghost: 7.0,\n    target_normal: 11.0,\n\n    // --- SÄKRINGSSKYDD ---\n    fuse_limit_warning: 110,\n    fuse_limit_critical: 120,\n    fuse_hysteresis_temp: 5, \n\n    // --- TESLA ---\n    tesla_min: 6,\n    tesla_max: 16,\n    tesla_phases: [1,2,3],\n\n    // --- SKYDDSMEKANISMER (NYHET) ---\n    protection: {\n        min_off_minutes: 10,      // \"Short Cycle Protection\": Tid att vänta efter STOPP innan START (minuter)\n        ev_regulation_sec: 30     // \"Rate Limit\": Minsta tid mellan Ampere-ändringar (sekunder)\n    },\n\n    // --- REGLERING ---\n    hysteresis_buffer: 1200, // Sänkt till 1200W för att värmen ska starta lättare\n    safety_margin: 800,      // Avståndet till taket\n    tesla_step_min: 1,       // 2A steg för lugnare gång\n    router_retry_ms: 60000,\n\n    // --- LAST-DEFINITIONER ---\n    loads_config: {\n        vvb: { watts: 3000, phases: [2,3] }, \n        rad: { watts: 3500, phases: [2,3] }, \n        avf: { watts: 500,  phases: [1] }\n    },\n\n    // --- TEMPERATUR-GRÄNSER (Ghost Mode) ---\n    temp_limits: {\n        critical: 19.0, \n        cold: 21.0      \n    },\n\n    // --- PRIORITERING ---\n    prio: {\n        ghost: {\n            rad_critical: 100, rad_cold: 60, rad_warm: 20,\n            vvb: 50,\n            tesla_panic: 50, tesla_normal: 0,\n            avf: -1\n        },\n        normal: {\n            rad: 60,\n            vvb_prio: 55, vvb_yield: 55,\n            tesla_panic: 95, tesla_normal: 90,\n            avf: 50\n        }\n    }\n};\n\n// 1. Spara config\nflow.set(\"sips_config\", config);\n\n// 2. Hantera State (Smart uppdatering)\nlet state = flow.get(\"sips_state\");\n\nif (!state) {\n    state = {\n        tesla: { amps: 0, actual_amps: 0, state: \"unknown\", geofence: \"unknown\", max_amps_dynamic: config.tesla_max, charge_limit: 80 },\n        loads: {},\n        grid: { l1: 0, l2: 0, l3: 0, power: 0 },\n        fuse: { l1: 0, l2: 0, l3: 0, max: 0 },\n        sim: { temp: 21.0, lastUpdate: Date.now() },\n        api: { count: 0, month: new Date().getMonth() },\n        history: {} // NYHET: För att minnas när vi stängde av saker\n    };\n    node.warn(\"Initialized New State\");\n}\n\n// 3. SYNKRONISERA\nif (!state.loads) state.loads = {};\nif (!state.history) state.history = {};\n\nfor (let key in config.loads_config) {\n    if (!state.loads[key]) {\n        state.loads[key] = { status: \"off\", prio: 50 };\n    }\n    // Initiera historik om den saknas\n    if (!state.history[key]) state.history[key] = { lastStop: 0, lastStart: 0 };\n    \n    state.loads[key].phases = config.loads_config[key].phases;\n    state.loads[key].watts = config.loads_config[key].watts;\n}\nif (!state.history.tesla) state.history.tesla = { lastStop: 0, lastStart: 0, lastRegulate: 0 };\n\nflow.set(\"sips_state\", state);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 910,
        "y": 320,
        "wires": [
            []
        ]
    },
    {
        "id": "ed0005ea6011b01a",
        "type": "function",
        "z": "3eed00b8c7a9ef73",
        "d": true,
        "name": "Format Influx Data",
        "func": "// FORMAT INFLUX DATA V13.1 (+ FRC & CAR)\nlet sips = msg.sips;\nlet log = sips.log || {};\nlet config = flow.get(\"sips_config\") || {};\n\nfunction safe(val) { return (val === undefined || val === null || isNaN(val)) ? 0 : val; }\n\nlet vvb = sips.loads.vvb.status === \"on\" ? 1 : 0;\nlet rad = sips.loads.rad.status === \"on\" ? 1 : 0;\nlet avf = sips.loads.avf.status === \"on\" ? 1 : 0;\nlet maxLimit = config.tesla_max || 16; \n\nreturn [\n    { payload: vvb },                          // 1\n    { payload: rad },                          // 2\n    { payload: avf },                          // 3\n    { payload: safe(sips.tesla.amps) },        // 4\n    { payload: safe(sips.fuse.l1) },           // 5\n    { payload: safe(sips.fuse.l2) },           // 6\n    { payload: safe(sips.fuse.l3) },           // 7\n    { payload: safe(maxLimit) },               // 8\n    { payload: safe(sips.api.count) },         // 9\n    { payload: safe(log.limit) },              // 10\n    { payload: safe(log.used) },               // 11\n    { payload: safe(log.target) },             // 12\n    { payload: safe(log.ghost) },              // 13\n    { payload: safe(sips.tesla.actual_amps) }, // 14\n    { payload: safe(sips.goe.frc) },           // 15 [NY] Force State (0/1/2)\n    { payload: safe(sips.goe.car) }            // 16 [NY] Car Status (1-4)\n];",
        "outputs": 16,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 830,
        "y": 1000,
        "wires": [
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            []
        ]
    },
    {
        "id": "9cc697e5e2f1d6b3",
        "type": "debug",
        "z": "3eed00b8c7a9ef73",
        "g": "cf8bf0b14e7e4aa4",
        "name": "debug 2",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1510,
        "y": 300,
        "wires": []
    },
    {
        "id": "fa6a33cd942a9c83",
        "type": "mqtt-broker",
        "name": "RPI",
        "broker": "localhost",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "8d24e520361b7e2c",
        "type": "influxdb",
        "hostname": "127.0.0.1",
        "port": "8086",
        "protocol": "http",
        "database": "sensors",
        "name": "",
        "usetls": false,
        "tls": "",
        "influxdbVersion": "1.x",
        "url": "http://localhost:8086",
        "timeout": "10",
        "rejectUnauthorized": true
    }
]