[
    {
        "id": "90b4bf1bba3c4a1b",
        "type": "tab",
        "label": "flows_SIPS_VFUSE_BTEA_V12",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "85b67b29fab3b089",
        "type": "group",
        "z": "90b4bf1bba3c4a1b",
        "name": "1. INPUT LAYER (V12.2 - Type Safe)",
        "style": {
            "stroke": "#92d04f",
            "fill": "#f3f9f0",
            "label": true
        },
        "nodes": [
            "202e1ca17013284a",
            "475c159080bef8be",
            "ae22d590ff91b02f",
            "d9db2d724be520a0",
            "5b2c7d53c99f94a8",
            "395f85f432daa741",
            "4909369c367a7ad9",
            "28c566917db56b65",
            "85e504f61a1dbf2f",
            "1cbf7ca219221933",
            "25058602032ba46d",
            "273f10e45e0921b4",
            "a68a60136cbaf8e2"
        ],
        "x": 34,
        "y": 119,
        "w": 512,
        "h": 562
    },
    {
        "id": "2f9b39ce199aae01",
        "type": "group",
        "z": "90b4bf1bba3c4a1b",
        "name": "2. LOGIC LAYER (V12.2 - Resource Oriented)",
        "style": {
            "stroke": "#4f8dd0",
            "fill": "#e3f2fd",
            "label": true
        },
        "nodes": [
            "7c5f3a5d60b4a2fc",
            "629e166f08c339b5",
            "45aa5f156e6adba2",
            "da3ac3bb9f331510",
            "fdf60d768d2d5ec6",
            "848f89351b205a4d",
            "1595ebe4a2579fbc"
        ],
        "x": 574,
        "y": 119,
        "w": 692,
        "h": 262
    },
    {
        "id": "523a1fbb17768ba3",
        "type": "group",
        "z": "90b4bf1bba3c4a1b",
        "name": "3. OUTPUT LAYER (Sequential + RBE Router)",
        "style": {
            "stroke": "#d04f4f",
            "fill": "#f9f0f0",
            "label": true
        },
        "nodes": [
            "4cbd5be1452b569b",
            "53deab53571f696b",
            "f6d13f23dcb44bcc",
            "5ef4546ccf5d8aa6"
        ],
        "x": 1434,
        "y": 159,
        "w": 832,
        "h": 202
    },
    {
        "id": "8759a84d80e51cc0",
        "type": "group",
        "z": "90b4bf1bba3c4a1b",
        "name": "4. LOGGING LAYER (InfluxDB - Type Fixed)",
        "style": {
            "stroke": "#999999",
            "fill": "#f0f0f0",
            "label": true
        },
        "nodes": [
            "47c8a4684260062b",
            "561108c3f50c350c",
            "7687d069b6670d70",
            "cc03ecb002548446",
            "03f9578c67ae30dd",
            "840e0a0e6c4af07a",
            "509b0df0e40f6219",
            "258a61d8b59d36c6",
            "e8c6eb1641062463",
            "6b0b8414c5e8837b",
            "89ee796e418a3687",
            "9fcef833d7b8753f",
            "cd34601cd5d01fc1",
            "829f7f54872512df",
            "c496781e55a93233",
            "c3b1cd746a9a1222",
            "77eeaf4729dfeb23",
            "dcdffa52412aead1",
            "d88fe1eb7ec44305",
            "9ee12cef89a4ae99",
            "a06e2d9decc629dd",
            "5db628d111f76339",
            "48efa557a81475d9",
            "48e2add58bb1d2fd",
            "af7ff91e628c37cc",
            "3e5341549e80473c",
            "9a3a852fb5e25bec",
            "c268619a93b7e2ed"
        ],
        "x": 1034,
        "y": 619,
        "w": 1262,
        "h": 662
    },
    {
        "id": "202e1ca17013284a",
        "type": "mqtt in",
        "z": "90b4bf1bba3c4a1b",
        "g": "85b67b29fab3b089",
        "name": "IN: Grid Metrics",
        "topic": "spB_app1_v1/BT01-S1-F-S/NDATA/IoT_Edge_1/IoT_Device_1/#",
        "qos": "0",
        "datatype": "json",
        "broker": "fa6a33cd942a9c83",
        "inputs": 0,
        "x": 140,
        "y": 160,
        "wires": [
            [
                "a68a60136cbaf8e2",
                "6b0b8414c5e8837b",
                "c496781e55a93233",
                "c3b1cd746a9a1222"
            ]
        ]
    },
    {
        "id": "475c159080bef8be",
        "type": "mqtt in",
        "z": "90b4bf1bba3c4a1b",
        "g": "85b67b29fab3b089",
        "name": "IN: Tesla State",
        "topic": "teslamate/cars/1/state",
        "qos": "1",
        "broker": "fa6a33cd942a9c83",
        "inputs": 0,
        "x": 140,
        "y": 200,
        "wires": [
            [
                "a68a60136cbaf8e2"
            ]
        ]
    },
    {
        "id": "ae22d590ff91b02f",
        "type": "mqtt in",
        "z": "90b4bf1bba3c4a1b",
        "g": "85b67b29fab3b089",
        "name": "IN: Tesla Geofence",
        "topic": "teslamate/cars/1/geofence",
        "qos": "1",
        "broker": "fa6a33cd942a9c83",
        "inputs": 0,
        "x": 150,
        "y": 240,
        "wires": [
            [
                "a68a60136cbaf8e2"
            ]
        ]
    },
    {
        "id": "d9db2d724be520a0",
        "type": "mqtt in",
        "z": "90b4bf1bba3c4a1b",
        "g": "85b67b29fab3b089",
        "name": "IN: Tesla Cur Req",
        "topic": "teslamate/cars/1/charge_current_request",
        "qos": "1",
        "broker": "fa6a33cd942a9c83",
        "inputs": 0,
        "x": 150,
        "y": 280,
        "wires": [
            [
                "a68a60136cbaf8e2",
                "9a3a852fb5e25bec"
            ]
        ]
    },
    {
        "id": "5b2c7d53c99f94a8",
        "type": "mqtt in",
        "z": "90b4bf1bba3c4a1b",
        "g": "85b67b29fab3b089",
        "name": "IN: Tesla Cur Max",
        "topic": "teslamate/cars/1/charge_current_request_max",
        "qos": "1",
        "broker": "fa6a33cd942a9c83",
        "inputs": 0,
        "x": 150,
        "y": 320,
        "wires": [
            [
                "a68a60136cbaf8e2",
                "c268619a93b7e2ed"
            ]
        ]
    },
    {
        "id": "395f85f432daa741",
        "type": "mqtt in",
        "z": "90b4bf1bba3c4a1b",
        "g": "85b67b29fab3b089",
        "name": "IN: Homey Loads",
        "topic": "homey/logic/+",
        "qos": "1",
        "broker": "fa6a33cd942a9c83",
        "inputs": 0,
        "x": 150,
        "y": 360,
        "wires": [
            [
                "a68a60136cbaf8e2"
            ]
        ]
    },
    {
        "id": "4909369c367a7ad9",
        "type": "mqtt in",
        "z": "90b4bf1bba3c4a1b",
        "g": "85b67b29fab3b089",
        "name": "IN: Shelly Feedback",
        "topic": "shellies/+/relay/0",
        "qos": "1",
        "broker": "fa6a33cd942a9c83",
        "inputs": 0,
        "x": 150,
        "y": 400,
        "wires": [
            [
                "a68a60136cbaf8e2"
            ]
        ]
    },
    {
        "id": "28c566917db56b65",
        "type": "mqtt in",
        "z": "90b4bf1bba3c4a1b",
        "g": "85b67b29fab3b089",
        "name": "IN: Tesla Battery %",
        "topic": "teslamate/cars/1/battery_level",
        "qos": "1",
        "broker": "fa6a33cd942a9c83",
        "inputs": 0,
        "x": 150,
        "y": 480,
        "wires": [
            [
                "a68a60136cbaf8e2"
            ]
        ]
    },
    {
        "id": "85e504f61a1dbf2f",
        "type": "mqtt in",
        "z": "90b4bf1bba3c4a1b",
        "g": "85b67b29fab3b089",
        "name": "IN: Tesla Limit %",
        "topic": "teslamate/cars/1/charge_limit_soc",
        "qos": "1",
        "broker": "fa6a33cd942a9c83",
        "inputs": 0,
        "x": 150,
        "y": 520,
        "wires": [
            [
                "a68a60136cbaf8e2"
            ]
        ]
    },
    {
        "id": "1cbf7ca219221933",
        "type": "mqtt in",
        "z": "90b4bf1bba3c4a1b",
        "g": "85b67b29fab3b089",
        "name": "IN: Charging State",
        "topic": "teslamate/cars/1/charging_state",
        "qos": "1",
        "broker": "fa6a33cd942a9c83",
        "inputs": 0,
        "x": 150,
        "y": 560,
        "wires": [
            [
                "a68a60136cbaf8e2"
            ]
        ]
    },
    {
        "id": "25058602032ba46d",
        "type": "mqtt in",
        "z": "90b4bf1bba3c4a1b",
        "g": "85b67b29fab3b089",
        "name": "IN: Actual (Restore)",
        "topic": "teslamate/cars/1/charger_actual_current",
        "qos": "1",
        "broker": "fa6a33cd942a9c83",
        "inputs": 0,
        "x": 150,
        "y": 600,
        "wires": [
            [
                "a68a60136cbaf8e2",
                "3e5341549e80473c"
            ]
        ]
    },
    {
        "id": "273f10e45e0921b4",
        "type": "mqtt in",
        "z": "90b4bf1bba3c4a1b",
        "g": "85b67b29fab3b089",
        "name": "IN: Storage",
        "topic": "system/sips/storage",
        "qos": "1",
        "broker": "fa6a33cd942a9c83",
        "inputs": 0,
        "x": 170,
        "y": 640,
        "wires": [
            [
                "a68a60136cbaf8e2"
            ]
        ]
    },
    {
        "id": "a68a60136cbaf8e2",
        "type": "function",
        "z": "90b4bf1bba3c4a1b",
        "g": "85b67b29fab3b089",
        "name": "INPUT MAPPER V12",
        "func": "// INPUT MAPPER V12 (Added Charge Limit SOC)\nlet sips = flow.get(\"sips_state\");\n\n// --- 1. SJÄLVLÄKANDE SKYDDSMEKANISM ---\nif (!sips || !sips.loads || !sips.grid) {\n    sips = sips || {};\n    if (!sips.tesla) sips.tesla = { amps: 0, actual_amps: 0, state: \"unknown\", geofence: \"unknown\", charge_limit: 80 };\n    if (!sips.loads) sips.loads = { \n        vvb: { status: \"off\", prio: 2, phases: [2,3] }, \n        rad: { status: \"off\", prio: 3, phases: [1,2,3] }, \n        avf: { status: \"off\", prio: 4, phases: [1] } \n    };\n    if (!sips.grid) sips.grid = { l1: 0, l2: 0, l3: 0, power: 0, energy_used_hour: 0 };\n    if (!sips.fuse) sips.fuse = { l1: 0, l2: 0, l3: 0, max: 0 };\n    if (!sips.api) sips.api = { count: 0, month: new Date().getMonth() };\n}\n\nlet trigger = false;\n\n// --- 2. RESTORE MEMORY & REALITY SYNC ---\nif (msg.topic.includes(\"charger_actual_current\")) {\n    let actual = parseFloat(msg.payload);\n    sips.tesla.actual_amps = actual;\n    if (sips.tesla.amps === 0 && actual > 1) sips.tesla.amps = Math.round(actual);\n}\n\n// --- 3. GRID & ENERGY ---\nelse if (msg.payload && msg.payload.metrics) {\n    let m = msg.payload.metrics;\n    if (!sips.grid) sips.grid = {};\n    sips.grid.l1 = m.Current_L1;\n    sips.grid.l2 = m.Current_L2;\n    sips.grid.l3 = m.Current_L3;\n    sips.grid.power = m.Power_Total;\n    \n    if (m.Energy_Total !== undefined) {\n        let currentTotalKwh = parseFloat(m.Energy_Total);\n        let now = new Date();\n        let currentHour = now.getHours();\n        let energyState = flow.get(\"sips_energy_state\") || { startEnergy: currentTotalKwh, currentHour: -1 };\n        if (energyState.currentHour !== currentHour) {\n            energyState.currentHour = currentHour;\n            energyState.startEnergy = currentTotalKwh;\n        }\n        let used = currentTotalKwh - energyState.startEnergy;\n        if (used < 0) { used = 0; energyState.startEnergy = currentTotalKwh; }\n        flow.set(\"sips_energy_state\", energyState);\n        sips.grid.energy_used_hour = used;\n        sips.grid.minutes_passed = now.getMinutes();\n    }\n    trigger = true;\n}\n\n// --- 4. TESLA INPUTS ---\nelse if (msg.topic.includes(\"charge_current_request\") && !msg.topic.includes(\"max\")) sips.tesla.amps = parseFloat(msg.payload);\nelse if (msg.topic.includes(\"charge_current_request_max\")) sips.tesla.max_amps_dynamic = parseFloat(msg.payload);\nelse if (msg.topic.endsWith(\"/state\")) sips.tesla.state = msg.payload.toString().toLowerCase();\nelse if (msg.topic.includes(\"charging_state\")) sips.tesla.charging_state = msg.payload.toString(); \nelse if (msg.topic.includes(\"plugged_in\")) sips.tesla.plugged_in = (msg.payload === true || msg.payload === \"true\");\nelse if (msg.topic.includes(\"geofence\")) sips.tesla.geofence = msg.payload.toString();\nelse if (msg.topic.includes(\"battery_level\")) sips.tesla.battery_level = parseFloat(msg.payload);\nelse if (msg.topic.includes(\"charge_limit_soc\")) sips.tesla.charge_limit = parseFloat(msg.payload);\n\n// --- 5. STORAGE & HOMEY ---\nelse if (msg.topic === \"system/sips/storage\") {\n    let data = msg.payload;\n    if (typeof data === \"string\") { try { data = JSON.parse(data); } catch(e) {} }\n    if (data && data.c !== undefined) { sips.api.count = data.c; sips.api.month = data.m; }\n}\nelse if (msg.topic.includes(\"homey/logic/\")) {\n    // Generisk laddning av laster\n    if (msg.topic.includes(\"vvb\")) sips.loads.vvb.status = (msg.payload === 1 || msg.payload === true || msg.payload === \"on\") ? \"on\" : \"off\";\n    if (msg.topic.includes(\"radiators\")) sips.loads.rad.status = (msg.payload === 1 || msg.payload === true || msg.payload === \"on\") ? \"on\" : \"off\";\n    if (msg.topic.includes(\"avf\")) sips.loads.avf.status = (msg.payload === 1 || msg.payload === true || msg.payload === \"on\") ? \"on\" : \"off\";\n}\nelse if (msg.topic.includes(\"shellies/\")) {\n    if (msg.topic.includes(\"vvb1\")) sips.loads.vvb.status = msg.payload;\n    if (msg.topic.includes(\"rad1\")) sips.loads.rad.status = msg.payload;\n    if (msg.topic.includes(\"avf1\")) sips.loads.avf.status = msg.payload;\n}\n\nflow.set(\"sips_state\", sips);\n\nif (trigger) {\n    msg.sips = sips;\n    return msg;\n}\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 420,
        "y": 320,
        "wires": [
            [
                "7c5f3a5d60b4a2fc"
            ]
        ]
    },
    {
        "id": "7c5f3a5d60b4a2fc",
        "type": "function",
        "z": "90b4bf1bba3c4a1b",
        "g": "2f9b39ce199aae01",
        "name": "MODEL: Fuse (I2t - Fixed)",
        "func": "let sips = msg.sips;\nlet config = flow.get(\"sips_config\") || { fuse_limit_critical: 120 };\n\nconst FUSE_SIZE = 20;\nconst TAU = 200;\nconst DT = 1.0;\n\nfunction calc(old_temp, current_amps) {\n    let load_ratio = current_amps / FUSE_SIZE;\n    let target_temp = load_ratio * load_ratio * 100;\n    let alpha = 1 - Math.exp(-DT / TAU);\n    return old_temp + alpha * (target_temp - old_temp);\n}\n\nif (!sips.fuse) sips.fuse = { l1: 0, l2: 0, l3: 0, max: 0 };\n\nsips.fuse.l1 = calc(sips.fuse.l1, sips.grid.l1);\nsips.fuse.l2 = calc(sips.fuse.l2, sips.grid.l2);\nsips.fuse.l3 = calc(sips.fuse.l3, sips.grid.l3);\n\n// SKYDDSLOGIK: Direkt detektion av extrem överlast (>50A)\nlet max_current_real = Math.max(sips.grid.l1, sips.grid.l2, sips.grid.l3);\n\nif (max_current_real > (FUSE_SIZE * 2.5)) {\n    // Instant Protection: Sätt temp till något som garanterat triggar Critical\n    let panicTemp = (config.fuse_limit_critical || 120) + 5;\n    sips.fuse.max = Math.max(sips.fuse.l1, sips.fuse.l2, sips.fuse.l3, panicTemp);\n} else {\n    sips.fuse.max = Math.max(sips.fuse.l1, sips.fuse.l2, sips.fuse.l3);\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 780,
        "y": 160,
        "wires": [
            [
                "629e166f08c339b5"
            ]
        ]
    },
    {
        "id": "629e166f08c339b5",
        "type": "function",
        "z": "90b4bf1bba3c4a1b",
        "g": "2f9b39ce199aae01",
        "name": "MODEL: House",
        "func": "// Termisk modell för huset\nlet sips = msg.sips;\nlet now = Date.now();\n\nif (!sips.sim) sips.sim = { temp: 21.0, lastUpdate: now };\n\nlet dt = (now - sips.sim.lastUpdate) / 3600000.0;\nif (dt > 1) dt = 1;\n\nif (sips.loads.rad.status === \"on\") {\n    sips.sim.temp += (3.0 * dt);\n    if (sips.sim.temp > 21) sips.sim.temp = 21;\n} else {\n    sips.sim.temp -= (2.0 * dt);\n    if (sips.sim.temp < 16) sips.sim.temp = 16;\n}\nsips.sim.lastUpdate = now;\n\n// Prio-logik för elementen\nsips.loads.rad.prio = (sips.sim.temp < 19.0) ? 99 : 3;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 960,
        "y": 160,
        "wires": [
            [
                "45aa5f156e6adba2"
            ]
        ]
    },
    {
        "id": "45aa5f156e6adba2",
        "type": "function",
        "z": "90b4bf1bba3c4a1b",
        "g": "2f9b39ce199aae01",
        "name": "RESOURCE MANAGER V12.1",
        "func": "// RESOURCE MANAGER V12.2 (Robust Connection Logic)\nlet sips = msg.sips;\nsips.resources = sips.resources || {};\n\n// --- 1. DEFINIERA TESLA OBJEKTET ---\nlet tesla = sips.tesla || {};\nlet teslaRes = {\n    id: \"tesla\",\n    type: \"controllable_load\",\n    priority: 15,\n    min_power: 1150, // 5A * 230V\n    phases: [1],\n    available: false,\n    reason: \"Initializing\"\n};\n\n// --- 2. VALIDERINGS-LOGIK ---\nlet isHome = (tesla.geofence === \"home\");\n\n// FIX V12.2: Robust detektering av kabel\n// Om charging_state är något annat än \"Disconnected\" så sitter kabeln i.\n// Detta fungerar även om 'plugged_in' saknas i MQTT-datan.\nlet state = tesla.charging_state || \"Disconnected\";\nlet isConnectedState = (state === \"Charging\" || state === \"Stopped\" || state === \"Complete\" || state === \"PluggedIn\");\n\nlet isConnected = (tesla.plugged_in === true || tesla.plugged_in === \"true\" || isConnectedState);\n\nlet isOnline = (tesla.state === \"online\" || tesla.state === \"charging\" || tesla.state === \"suspended\");\nlet isNotFull = (state !== \"Complete\");\n\n// SOC Check (Om vi har data)\nlet socRoom = true;\nif (tesla.charge_limit && tesla.battery_level) {\n    if (tesla.battery_level >= tesla.charge_limit) socRoom = false;\n}\n\n// --- 3. BESLUTSTRÄD ---\nif (!isHome) {\n    teslaRes.available = false;\n    teslaRes.reason = \"Away\";\n} else if (!isConnected) {\n    teslaRes.available = false;\n    teslaRes.reason = \"Disconnected\";\n} else if (!isOnline) {\n    teslaRes.available = false; // Kanske tillåta 'suspended' om vi vill väcka?\n    teslaRes.reason = \"Offline/Sleep\";\n} else if (!isNotFull || !socRoom) {\n    teslaRes.available = false;\n    teslaRes.reason = \"Battery Full\";\n} else {\n    // Allt ser bra ut!\n    teslaRes.available = true;\n    teslaRes.reason = \"Ready\";\n}\n\n// Spara ner i det strukturerade objektet\nsips.resources.tesla = teslaRes;\n\n// --- 4. ANDRA RESURSER (VVB etc) ---\n// Hämtar prio från SIPS-objektet (som satts av Strategy/Init)\n// Vi sätter default om det saknas\nlet vvbPrio = sips.loads.vvb.prio !== undefined ? sips.loads.vvb.prio : 50;\nlet radPrio = sips.loads.rad.prio !== undefined ? sips.loads.rad.prio : 30;\nlet avfPrio = sips.loads.avf.prio !== undefined ? sips.loads.avf.prio : 10;\n\nsips.resources.vvb = { id: \"vvb\", available: true, priority: vvbPrio };\nsips.resources.rad = { id: \"rad\", available: true, priority: radPrio };\nsips.resources.avf = { id: \"avf\", available: true, priority: avfPrio };\n\nflow.set(\"sips_state\", sips);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1010,
        "y": 220,
        "wires": [
            [
                "da3ac3bb9f331510"
            ]
        ]
    },
    {
        "id": "da3ac3bb9f331510",
        "type": "function",
        "z": "90b4bf1bba3c4a1b",
        "g": "2f9b39ce199aae01",
        "name": "STRATEGY V12.5",
        "func": "// STRATEGY V12.5 - \"One Action Per Cycle\" & Configurable Temps\nlet sips = msg.sips;\nlet plan = [];\n\n// --- HÄMTA CONFIG ---\nlet config = flow.get(\"sips_config\");\nif (!config || !config.prio) { \n    node.error(\"Config missing! Run INIT.\"); \n    return null; \n}\n\n// Hämta last-data\nlet lConf = config.loads_config || { \n    vvb: {watts:3000, phases:[1,2,3]}, \n    rad: {watts:3500, phases:[1,2,3]}, \n    avf: {watts:500,  phases:[1]} \n};\n\nconst VVB_EST_WATTS = lConf.vvb.watts; \nconst RAD_EST_WATTS = lConf.rad.watts;\nconst AVF_EST_WATTS = lConf.avf.watts;\nconst CAR_MIN_WATTS = config.tesla_min * 230; \n\n// --- 1. TID & MODE ---\nlet now = new Date();\nlet isWinter = (now.getMonth()+1 === 12 || now.getMonth()+1 <= 2);\nlet isHighLoadTime = (now.getHours() >= 6 && now.getHours() < 21);\nlet isGhostMode = isWinter && isHighLoadTime;\nlet targetKw = isGhostMode ? config.target_ghost : config.target_normal;\n\n// --- 2. BUDGET & MÄTVÄRDEN ---\nlet usedKwh = sips.grid.energy_used_hour || 0;\nlet minutesPassed = Math.max(sips.grid.minutes_passed || 1, 1);\nlet kwhLeft = targetKw - usedKwh;\nlet maxAllowedPowerKw = (kwhLeft / ((60 - minutesPassed) / 60.0)) - 0.5;\nmaxAllowedPowerKw = Math.max(Math.min(maxAllowedPowerKw, 13.5), 0);\nconst POWER_LIMIT = maxAllowedPowerKw * 1000;\nlet totalPower = sips.grid.power;\n\nsips.log = { limit: POWER_LIMIT, target: targetKw, used: usedKwh, ghost: isGhostMode ? 1 : 0 };\n\n// --- 3. PRIORITERING ---\nlet rTesla = sips.resources.tesla;\nlet rVvb = sips.resources.vvb;\nlet rRad = sips.resources.rad;\nlet rAvf = sips.resources.avf;\nlet houseTemp = sips.sim ? sips.sim.temp : 21.0;\nlet panicCharge = (sips.tesla.battery_level < 20);\n\nif (isGhostMode) {\n    let p = config.prio.ghost;\n    // Hämtar gränser från config (Separation of Concerns)\n    let limits = config.temp_limits || { critical: 19.0, cold: 20.0 };\n\n    if (houseTemp < limits.critical) rRad.priority = p.rad_critical;\n    else if (houseTemp < limits.cold) rRad.priority = p.rad_cold;\n    else rRad.priority = p.rad_warm;\n    \n    rAvf.priority = p.avf; rVvb.priority = p.vvb;\n    rTesla.priority = panicCharge ? p.tesla_panic : p.tesla_normal;\n} else {\n    let p = config.prio.normal;\n    rRad.priority = p.rad; rAvf.priority = p.avf;\n    if (panicCharge) { rTesla.priority = p.tesla_panic; rVvb.priority = p.vvb_yield; }\n    else { rVvb.priority = p.vvb_prio; rTesla.priority = p.tesla_normal; }\n}\n\nlet resources = [\n    { ...rTesla, active: (sips.tesla.state === \"charging\" || sips.tesla.state === \"starting\"), type: \"dynamic\", phases: config.tesla_phases || [1] },\n    { ...rVvb, active: (sips.loads.vvb.status === \"on\"), type: \"binary\", watts: VVB_EST_WATTS, phases: lConf.vvb.phases },\n    { ...rRad, active: (sips.loads.rad.status === \"on\"), type: \"binary\", watts: RAD_EST_WATTS, phases: lConf.rad.phases },\n    { ...rAvf, active: (sips.loads.avf.status === \"on\"), type: \"binary\", watts: AVF_EST_WATTS, phases: lConf.avf.phases }\n];\nresources.sort((a,b) => a.priority - b.priority);\n\n// --- 4. ACTION LOGIC ---\nlet shedMode = false;\nlet statusText = `${isGhostMode ? \"GHOST\" : \"LOW\"} (${targetKw}kW) `;\n\n// A. FORCE OFF\nresources.forEach(r => {\n    if (r.priority < 0 && r.active) {\n        plan.push({ id: r.id, action: r.type === \"dynamic\" ? \"stop\" : \"off\" });\n    }\n});\n\n// B. SHEDDING\nlet overloadL1 = sips.fuse.l1 > config.fuse_limit_warning;\nlet overloadL2 = sips.fuse.l2 > config.fuse_limit_warning;\nlet overloadL3 = sips.fuse.l3 > config.fuse_limit_warning;\nlet totalOverload = totalPower > POWER_LIMIT;\n\nif (totalOverload || overloadL1 || overloadL2 || overloadL3) {\n    shedMode = true;\n    let reductionNeeded = 0;\n    \n    if (sips.fuse.max > config.fuse_limit_critical) {\n        reductionNeeded = 99000; statusText = \"CRITICAL PANIC\";\n    } else {\n        reductionNeeded = Math.max(totalPower - POWER_LIMIT, 2000); \n    }\n\n    for (let r of resources) {\n        if (!r.active) continue;\n        if (r.priority >= 100) continue; \n\n        let contributesToProblem = false;\n        if (totalOverload) contributesToProblem = true;\n        else {\n            let hitsL1 = overloadL1 && r.phases.includes(1);\n            let hitsL2 = overloadL2 && r.phases.includes(2);\n            let hitsL3 = overloadL3 && r.phases.includes(3);\n            if (hitsL1 || hitsL2 || hitsL3) contributesToProblem = true;\n        }\n\n        if (!contributesToProblem) continue; \n\n        if (r.type === \"dynamic\") {\n            if (!r.available) continue; \n            let ampsToReduce = Math.ceil(reductionNeeded / 230);\n            if (ampsToReduce < 3) ampsToReduce = 3; \n            let newAmps = sips.tesla.amps - ampsToReduce;\n            if (newAmps < config.tesla_min) {\n                plan.push({ id: r.id, action: \"stop\" });\n                reductionNeeded -= (sips.tesla.amps * 230);\n                // Dynamic kan justeras snabbt, men vi bryter för säkerhets skull\n                break; \n            } else {\n                plan.push({ id: r.id, action: \"set\", value: newAmps });\n                reductionNeeded = 0;\n                // Här bryter vi INTE, för Tesla-justering är \"snäll\". \n                // Men om vi vill vara super-stabila, kan vi aktivera break här också.\n                // Vi låter den vara öppen för finlir.\n            }\n        } else {\n            // BINÄR LAST: Stäng av och avbryt loopen direkt!\n            plan.push({ id: r.id, action: \"off\" });\n            break; // <--- HÄR ÄR FIXEN: One Kill Per Cycle\n        }\n        if (reductionNeeded <= 0) break;\n    }\n}\n// C. RECOVERY\nelse {\n    let coolDownDrop = config.fuse_hysteresis_temp || 5; \n    let coolDownLimit = (config.fuse_limit_warning || 110) - coolDownDrop;\n    \n    if (sips.fuse.max > coolDownLimit) {\n        statusText = `COOLING (${Math.round(sips.fuse.max)}°C > ${coolDownLimit})`;\n    } \n    else {\n        // Recovery Logic\n        let wattsAvailable = POWER_LIMIT - totalPower;\n        let startOrder = [...resources].sort((a,b) => b.priority - a.priority);\n        let actionTaken = false; // Ny flagga för att begränsa påslag\n        \n        for (let r of startOrder) {\n            if (actionTaken && r.type === \"binary\") continue; // Max en binär start per cykel!\n            if (r.priority < 0 || r.active) continue;\n            \n            if (r.type === \"binary\") {\n                let requiredBuffer = config.hysteresis_buffer || 500;\n                if (wattsAvailable > (r.watts + requiredBuffer) && r.available) {\n                    plan.push({ id: r.id, action: \"on\" });\n                    wattsAvailable -= r.watts;\n                    actionTaken = true; // Markera att vi startat något\n                }\n            }\n            else if (r.id === \"tesla\" && r.available) {\n                let req = CAR_MIN_WATTS + config.safety_margin;\n                if (wattsAvailable > req) {\n                    plan.push({ id: \"tesla\", action: \"start\" });\n                    plan.push({ id: \"tesla\", action: \"set\", value: config.tesla_min });\n                    sips.tesla.amps = config.tesla_min;\n                    wattsAvailable -= CAR_MIN_WATTS;\n                    // Bilen får starta samtidigt som annat, den mjukstartar ändå.\n                }\n            }\n        }\n        \n        // Smart Turbo (Bara om bilen redan laddar)\n        let car = resources.find(r => r.id === \"tesla\");\n        if (car && car.active && car.available && wattsAvailable > config.hysteresis_buffer) {\n            let headroom = Math.floor((wattsAvailable - config.safety_margin) / 230);\n            if (headroom >= 1) {\n                let newAmps = Math.min(sips.tesla.amps + headroom, config.tesla_max);\n                if (newAmps > sips.tesla.amps) plan.push({ id: \"tesla\", action: \"set\", value: newAmps });\n            }\n        }\n    }\n}\n\nif (plan.find(p => p.id === \"tesla\")) sips.api.count++;\n\nlet sysState = \"normal\";\nif (sips.fuse.max > config.fuse_limit_critical) sysState = \"critical\";\nelse if (shedMode || sips.fuse.max > config.fuse_limit_warning) sysState = \"warning\";\nelse if (resources.some(r => r.priority > 0 && !r.active && r.available)) sysState = \"recovery\";\n\nflow.set(\"sips_state\", sips);\nmsg.plan = plan;\nmsg.systemState = sysState;\nnode.status({ fill: sysState===\"normal\"?\"green\":sysState===\"warning\"?\"orange\":\"red\", shape:\"dot\", text: statusText });\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1150,
        "y": 280,
        "wires": [
            [
                "4cbd5be1452b569b",
                "a06e2d9decc629dd"
            ]
        ]
    },
    {
        "id": "4cbd5be1452b569b",
        "type": "function",
        "z": "90b4bf1bba3c4a1b",
        "g": "523a1fbb17768ba3",
        "name": "ROUTER (V12.8)",
        "func": "let plan = msg.plan;\nlet sips = flow.get(\"sips_state\");\nlet config = flow.get(\"sips_config\") || {}; // Hämta config\n\n// Hämta Retry-tid från config, eller använd 60 sek som fallback\nconst COMMAND_TTL = config.router_retry_ms || 60000;\n\n// --- 1. HÄMTA ROUTER-MINNE ---\nlet routerStore = context.get(\"routerStore\") || { \n    lastState: \"\", \n    lastTs: 0,\n    devices: {} \n};\n\nlet now = Date.now();\n\n// --- 2. STATUS-RBE ---\nlet sendStatus = false;\nconst HEARTBEAT_MS = 300000; \n\nif (msg.systemState !== routerStore.lastState) sendStatus = true;\nelse if ((now - routerStore.lastTs) > HEARTBEAT_MS) sendStatus = true;\n\nlet statusMsg = null;\nif (sendStatus) {\n    statusMsg = { topic: \"homey/system/state\", payload: msg.systemState, qos: 1 };\n    routerStore.lastState = msg.systemState;\n    routerStore.lastTs = now;\n}\n\n// --- 3. KOMMANDO-RBE (Med Configurable Retry) ---\nlet mqttMsgs = [];\n\nif (plan) {\n    // Sortera: Set före Start\n    plan.sort((a,b) => {\n        const order = { \"set\": 1, \"start\": 2, \"stop\": 3, \"off\": 4, \"on\": 5 };\n        return (order[a.action] || 99) - (order[b.action] || 99);\n    });\n\n    plan.forEach(cmd => {\n        let cmdValue = cmd.value !== undefined ? cmd.value : \"\";\n        let cmdSignature = `${cmd.action}_${cmdValue}`;\n        let deviceId = cmd.id;\n\n        let lastEntry = routerStore.devices[deviceId] || { cmd: \"\", ts: 0 };\n\n        // SPAM FILTER: Skicka om nytt kommando ELLER tiden gått ut (TTL)\n        if (lastEntry.cmd !== cmdSignature || (now - lastEntry.ts) > COMMAND_TTL) {\n            \n            routerStore.devices[deviceId] = { cmd: cmdSignature, ts: now };\n\n            if (cmd.id === \"tesla\") {\n                if (cmd.action === \"set\")   mqttMsgs.push({ topic: \"homey/input/tesla_set_amps\", payload: cmd.value.toString() });\n                if (cmd.action === \"start\") mqttMsgs.push({ topic: \"homey/input/tesla_start\", payload: \"true\" });\n                if (cmd.action === \"stop\")  mqttMsgs.push({ topic: \"homey/input/tesla_stop\", payload: \"true\" });\n            } else {\n                let topic = \"\";\n                if (cmd.id === \"vvb\") topic = \"shellies/vvb1/relay/0/command\";\n                if (cmd.id === \"rad\") topic = \"shellies/rad1/relay/0/command\";\n                if (cmd.id === \"avf\") topic = \"shellies/avf1/relay/0/command\";\n                \n                if (topic) node.send([null, { topic: topic, payload: cmd.action, qos: 1 }, null]);\n            }\n        }\n    });\n}\n\ncontext.set(\"routerStore\", routerStore);\n\n// --- 4. UTGÅNGAR ---\nlet storageMsg = null;\nlet teslaActive = mqttMsgs.some(m => m.topic.includes(\"tesla\"));\n\nif (teslaActive && plan && plan.find(p => p.id === \"tesla\")) {\n    storageMsg = { topic: \"system/sips/storage\", payload: JSON.stringify({c: sips.api.count, m: sips.api.month}), retain: true, qos: 1 };\n}\n\nlet misc = [];\nif (statusMsg) misc.push(statusMsg);\nif (storageMsg) misc.push(storageMsg);\n\nif (mqttMsgs.length === 0 && misc.length === 0) return null;\n\nreturn [mqttMsgs, null, misc];",
        "outputs": 3,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1550,
        "y": 220,
        "wires": [
            [
                "53deab53571f696b",
                "5ef4546ccf5d8aa6"
            ],
            [
                "f6d13f23dcb44bcc",
                "5ef4546ccf5d8aa6"
            ],
            [
                "f6d13f23dcb44bcc",
                "5ef4546ccf5d8aa6"
            ]
        ]
    },
    {
        "id": "fdf60d768d2d5ec6",
        "type": "function",
        "z": "90b4bf1bba3c4a1b",
        "g": "2f9b39ce199aae01",
        "name": "Uppdatera INIT (V12.8)",
        "func": "// INIT V12.15 - Temp Limits & Optimized Buffers\nlet config = {\n    // --- TARIFF & BUDGET ---\n    target_ghost: 5.0,\n    target_normal: 11.0,\n\n    // --- SÄKRINGSSKYDD ---\n    fuse_limit_warning: 110,\n    fuse_limit_critical: 120,\n    fuse_hysteresis_temp: 5, \n\n    // --- TESLA ---\n    tesla_min: 5,\n    tesla_max: 13,\n    tesla_phases: [1],\n\n    // --- REGLERING ---\n    hysteresis_buffer: 500,  // Sänkt till 500W för att matcha din strategi\n    safety_margin: 500,      // Sänkt till 500W för aggressivare laddstart\n    router_retry_ms: 60000, \n\n    // --- LAST-DEFINITIONER ---\n    loads_config: {\n        vvb: { watts: 3000, phases: [2,3] }, \n        rad: { watts: 3500, phases: [2,3] }, // Worst case scenario\n        avf: { watts: 500,  phases: [1] }\n    },\n\n    // --- TEMPERATUR-GRÄNSER (Ghost Mode) ---\n    // NYHET: Här konfigurerar du gränserna för \"Ghost Mode\"\n    temp_limits: {\n        critical: 19.0, // Under 19°C = Prio 100 (Kritisk, stängs nästan aldrig av)\n        cold: 21.0      // Under 21°C = Prio 60 (Kallt, prioriteras över VVB)\n    },\n\n    // --- PRIORITERING ---\n    prio: {\n        ghost: {\n            rad_critical: 100, rad_cold: 60, rad_warm: 20,\n            vvb: 50,\n            tesla_panic: 50, tesla_normal: 0,\n            avf: -1\n        },\n        normal: {\n            rad: 30,\n            vvb_prio: 95, vvb_yield: 90,\n            tesla_panic: 95, tesla_normal: 90,\n            avf: 50\n        }\n    }\n};\n\n// 1. Spara config\nflow.set(\"sips_config\", config);\n\n// 2. Hantera State (Smart uppdatering)\nlet state = flow.get(\"sips_state\");\n\nif (!state) {\n    state = {\n        tesla: { amps: 0, actual_amps: 0, state: \"unknown\", geofence: \"unknown\", max_amps_dynamic: config.tesla_max, charge_limit: 80 },\n        loads: {},\n        grid: { l1: 0, l2: 0, l3: 0, power: 0 },\n        fuse: { l1: 0, l2: 0, l3: 0, max: 0 },\n        sim: { temp: 21.0, lastUpdate: Date.now() },\n        api: { count: 0, month: new Date().getMonth() }\n    };\n    node.warn(\"Initialized New State\");\n}\n\n// 3. SYNKRONISERA\nif (!state.loads) state.loads = {};\n\nfor (let key in config.loads_config) {\n    if (!state.loads[key]) {\n        state.loads[key] = { status: \"off\", prio: 50 };\n    }\n    state.loads[key].phases = config.loads_config[key].phases;\n    state.loads[key].watts = config.loads_config[key].watts;\n}\n\nflow.set(\"sips_state\", state);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 930,
        "y": 340,
        "wires": [
            []
        ]
    },
    {
        "id": "848f89351b205a4d",
        "type": "inject",
        "z": "90b4bf1bba3c4a1b",
        "g": "2f9b39ce199aae01",
        "name": "MANUAL INIT",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 700,
        "y": 300,
        "wires": [
            [
                "fdf60d768d2d5ec6"
            ]
        ]
    },
    {
        "id": "1595ebe4a2579fbc",
        "type": "inject",
        "z": "90b4bf1bba3c4a1b",
        "g": "2f9b39ce199aae01",
        "name": "Startup",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "x": 680,
        "y": 340,
        "wires": [
            [
                "fdf60d768d2d5ec6"
            ]
        ]
    },
    {
        "id": "53deab53571f696b",
        "type": "delay",
        "z": "90b4bf1bba3c4a1b",
        "g": "523a1fbb17768ba3",
        "name": "Tesla Rate Limit",
        "pauseType": "rate",
        "timeout": "5",
        "timeoutUnits": "seconds",
        "rate": "4",
        "nbRateUnits": "1",
        "rateUnits": "minute",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1960,
        "y": 200,
        "wires": [
            [
                "f6d13f23dcb44bcc",
                "5ef4546ccf5d8aa6"
            ]
        ]
    },
    {
        "id": "f6d13f23dcb44bcc",
        "type": "mqtt out",
        "z": "90b4bf1bba3c4a1b",
        "g": "523a1fbb17768ba3",
        "name": "MQTT OUT",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "fa6a33cd942a9c83",
        "x": 2150,
        "y": 260,
        "wires": []
    },
    {
        "id": "5ef4546ccf5d8aa6",
        "type": "debug",
        "z": "90b4bf1bba3c4a1b",
        "g": "523a1fbb17768ba3",
        "name": "Router Debug",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 2140,
        "y": 320,
        "wires": []
    },
    {
        "id": "47c8a4684260062b",
        "type": "influxdb out",
        "z": "90b4bf1bba3c4a1b",
        "g": "8759a84d80e51cc0",
        "influxdb": "8d24e520361b7e2c",
        "name": "VVB",
        "measurement": "homey/logic/vvb",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 2190,
        "y": 760,
        "wires": []
    },
    {
        "id": "561108c3f50c350c",
        "type": "influxdb out",
        "z": "90b4bf1bba3c4a1b",
        "g": "8759a84d80e51cc0",
        "influxdb": "8d24e520361b7e2c",
        "name": "Radiators",
        "measurement": "homey/logic/radiators",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 2200,
        "y": 800,
        "wires": []
    },
    {
        "id": "7687d069b6670d70",
        "type": "influxdb out",
        "z": "90b4bf1bba3c4a1b",
        "g": "8759a84d80e51cc0",
        "influxdb": "8d24e520361b7e2c",
        "name": "Avfuktare",
        "measurement": "homey/logic/avf",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 2200,
        "y": 840,
        "wires": []
    },
    {
        "id": "cc03ecb002548446",
        "type": "influxdb out",
        "z": "90b4bf1bba3c4a1b",
        "g": "8759a84d80e51cc0",
        "influxdb": "8d24e520361b7e2c",
        "name": "Tesla Req",
        "measurement": "tesla/charge/current/request",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 2200,
        "y": 880,
        "wires": []
    },
    {
        "id": "03f9578c67ae30dd",
        "type": "influxdb out",
        "z": "90b4bf1bba3c4a1b",
        "g": "8759a84d80e51cc0",
        "influxdb": "8d24e520361b7e2c",
        "name": "Fuse L1",
        "measurement": "fuse_temp_L1",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 2200,
        "y": 920,
        "wires": []
    },
    {
        "id": "840e0a0e6c4af07a",
        "type": "influxdb out",
        "z": "90b4bf1bba3c4a1b",
        "g": "8759a84d80e51cc0",
        "influxdb": "8d24e520361b7e2c",
        "name": "Fuse L2",
        "measurement": "fuse_temp_L2",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 2200,
        "y": 960,
        "wires": []
    },
    {
        "id": "509b0df0e40f6219",
        "type": "influxdb out",
        "z": "90b4bf1bba3c4a1b",
        "g": "8759a84d80e51cc0",
        "influxdb": "8d24e520361b7e2c",
        "name": "Fuse L3",
        "measurement": "fuse_temp_L3",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 2200,
        "y": 1000,
        "wires": []
    },
    {
        "id": "258a61d8b59d36c6",
        "type": "influxdb out",
        "z": "90b4bf1bba3c4a1b",
        "g": "8759a84d80e51cc0",
        "influxdb": "8d24e520361b7e2c",
        "name": "Tesla Max",
        "measurement": "tesla/charge_current_request_max",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 2200,
        "y": 1040,
        "wires": []
    },
    {
        "id": "e8c6eb1641062463",
        "type": "influxdb out",
        "z": "90b4bf1bba3c4a1b",
        "g": "8759a84d80e51cc0",
        "influxdb": "8d24e520361b7e2c",
        "name": "API Count",
        "measurement": "tesla/control_counter",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 2200,
        "y": 1080,
        "wires": []
    },
    {
        "id": "6b0b8414c5e8837b",
        "type": "function",
        "z": "90b4bf1bba3c4a1b",
        "g": "8759a84d80e51cc0",
        "name": "Extract Total_Power",
        "func": "// Extract power from grid JSON\nlet data = msg.payload;\nif (typeof data === \"string\") try { data = JSON.parse(data); } catch(e) {}\nif (data.metrics && data.metrics.Power_Total !== undefined) {\n    return { payload: parseFloat(data.metrics.Power_Total) };\n}\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1160,
        "y": 680,
        "wires": [
            [
                "89ee796e418a3687"
            ]
        ]
    },
    {
        "id": "89ee796e418a3687",
        "type": "influxdb out",
        "z": "90b4bf1bba3c4a1b",
        "g": "8759a84d80e51cc0",
        "influxdb": "8d24e520361b7e2c",
        "name": "shelly/3em/123/power",
        "measurement": "RPI_shelly/3em/123/power",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 1460,
        "y": 660,
        "wires": []
    },
    {
        "id": "9fcef833d7b8753f",
        "type": "influxdb out",
        "z": "90b4bf1bba3c4a1b",
        "g": "8759a84d80e51cc0",
        "influxdb": "8d24e520361b7e2c",
        "name": "shelly/3em/0/current",
        "measurement": "RPI_shelly/3em/0/current",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 1460,
        "y": 700,
        "wires": []
    },
    {
        "id": "cd34601cd5d01fc1",
        "type": "influxdb out",
        "z": "90b4bf1bba3c4a1b",
        "g": "8759a84d80e51cc0",
        "influxdb": "8d24e520361b7e2c",
        "name": "shelly/3em/1/current",
        "measurement": "RPI_shelly/3em/1/current",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 1460,
        "y": 740,
        "wires": []
    },
    {
        "id": "829f7f54872512df",
        "type": "influxdb out",
        "z": "90b4bf1bba3c4a1b",
        "g": "8759a84d80e51cc0",
        "influxdb": "8d24e520361b7e2c",
        "name": "shelly/3em/2/current",
        "measurement": "RPI_shelly/3em/2/current",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 1460,
        "y": 780,
        "wires": []
    },
    {
        "id": "c496781e55a93233",
        "type": "function",
        "z": "90b4bf1bba3c4a1b",
        "g": "8759a84d80e51cc0",
        "name": "Extract Currents",
        "func": "let data = msg.payload;\nif (typeof data === \"string\") try { data = JSON.parse(data); } catch(e) {}\nif (!data.metrics) return null;\n\nfunction get(val) { return { payload: parseFloat(val) }; }\nreturn [get(data.metrics.Current_L1), get(data.metrics.Current_L2), get(data.metrics.Current_L3)];",
        "outputs": 3,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1140,
        "y": 740,
        "wires": [
            [
                "9fcef833d7b8753f"
            ],
            [
                "cd34601cd5d01fc1"
            ],
            [
                "829f7f54872512df"
            ]
        ]
    },
    {
        "id": "c3b1cd746a9a1222",
        "type": "function",
        "z": "90b4bf1bba3c4a1b",
        "g": "8759a84d80e51cc0",
        "name": "Extract Power",
        "func": "let data = msg.payload;\nif (typeof data === \"string\") try { data = JSON.parse(data); } catch(e) {}\nif (!data.metrics) return null;\n\nfunction get(val) { return { payload: parseFloat(val) }; }\nreturn [get(data.metrics.Power_L1), get(data.metrics.Power_L2), get(data.metrics.Power_L3)];",
        "outputs": 3,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1140,
        "y": 840,
        "wires": [
            [
                "77eeaf4729dfeb23"
            ],
            [
                "dcdffa52412aead1"
            ],
            [
                "d88fe1eb7ec44305"
            ]
        ]
    },
    {
        "id": "77eeaf4729dfeb23",
        "type": "influxdb out",
        "z": "90b4bf1bba3c4a1b",
        "g": "8759a84d80e51cc0",
        "influxdb": "8d24e520361b7e2c",
        "name": "shelly/3em/0/power",
        "measurement": "RPI_shelly/3em/0/power",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 1450,
        "y": 820,
        "wires": []
    },
    {
        "id": "dcdffa52412aead1",
        "type": "influxdb out",
        "z": "90b4bf1bba3c4a1b",
        "g": "8759a84d80e51cc0",
        "influxdb": "8d24e520361b7e2c",
        "name": "shelly/3em/1/power",
        "measurement": "RPI_shelly/3em/1/power",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 1450,
        "y": 860,
        "wires": []
    },
    {
        "id": "d88fe1eb7ec44305",
        "type": "influxdb out",
        "z": "90b4bf1bba3c4a1b",
        "g": "8759a84d80e51cc0",
        "influxdb": "8d24e520361b7e2c",
        "name": "shelly/3em/2/power",
        "measurement": "RPI_shelly/3em/2/power",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 1450,
        "y": 900,
        "wires": []
    },
    {
        "id": "9ee12cef89a4ae99",
        "type": "influxdb out",
        "z": "90b4bf1bba3c4a1b",
        "g": "8759a84d80e51cc0",
        "influxdb": "8d24e520361b7e2c",
        "name": "tesla/charger_actual_current",
        "measurement": "tesla/charger_actual_current",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 1420,
        "y": 960,
        "wires": []
    },
    {
        "id": "a06e2d9decc629dd",
        "type": "function",
        "z": "90b4bf1bba3c4a1b",
        "g": "8759a84d80e51cc0",
        "name": "Format Influx Data",
        "func": "let sips = msg.sips;\nlet log = sips.log || {};\nfunction safe(val) { return (val === undefined || val === null || isNaN(val)) ? 0 : val; }\n\nlet vvb = sips.loads.vvb.status === \"on\" ? 1 : 0;\nlet rad = sips.loads.rad.status === \"on\" ? 1 : 0;\nlet avf = sips.loads.avf.status === \"on\" ? 1 : 0;\n\nreturn [\n    { payload: vvb },                          \n    { payload: rad },                          \n    { payload: avf },                          \n    { payload: safe(sips.tesla.amps) },        \n    { payload: safe(sips.fuse.l1) },           \n    { payload: safe(sips.fuse.l2) },           \n    { payload: safe(sips.fuse.l3) },           \n    { payload: safe(sips.tesla.max_amps_dynamic) }, \n    { payload: safe(sips.api.count) },         \n    { payload: safe(log.limit) },              \n    { payload: safe(log.used) },               \n    { payload: safe(log.target) },             \n    { payload: safe(log.ghost) }               \n];",
        "outputs": 13,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1910,
        "y": 1000,
        "wires": [
            [
                "47c8a4684260062b"
            ],
            [
                "561108c3f50c350c"
            ],
            [
                "7687d069b6670d70"
            ],
            [
                "cc03ecb002548446"
            ],
            [
                "03f9578c67ae30dd"
            ],
            [
                "840e0a0e6c4af07a"
            ],
            [
                "509b0df0e40f6219"
            ],
            [
                "258a61d8b59d36c6"
            ],
            [
                "e8c6eb1641062463"
            ],
            [
                "5db628d111f76339"
            ],
            [
                "48efa557a81475d9"
            ],
            [
                "48e2add58bb1d2fd"
            ],
            [
                "af7ff91e628c37cc"
            ]
        ]
    },
    {
        "id": "5db628d111f76339",
        "type": "influxdb out",
        "z": "90b4bf1bba3c4a1b",
        "g": "8759a84d80e51cc0",
        "influxdb": "8d24e520361b7e2c",
        "name": "Limit",
        "measurement": "strategy/power_limit",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 2210,
        "y": 1120,
        "wires": []
    },
    {
        "id": "48efa557a81475d9",
        "type": "influxdb out",
        "z": "90b4bf1bba3c4a1b",
        "g": "8759a84d80e51cc0",
        "influxdb": "8d24e520361b7e2c",
        "name": "Used",
        "measurement": "strategy/energy_used",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 2210,
        "y": 1160,
        "wires": []
    },
    {
        "id": "48e2add58bb1d2fd",
        "type": "influxdb out",
        "z": "90b4bf1bba3c4a1b",
        "g": "8759a84d80e51cc0",
        "influxdb": "8d24e520361b7e2c",
        "name": "Target",
        "measurement": "strategy/energy_target",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 2210,
        "y": 1200,
        "wires": []
    },
    {
        "id": "af7ff91e628c37cc",
        "type": "influxdb out",
        "z": "90b4bf1bba3c4a1b",
        "g": "8759a84d80e51cc0",
        "influxdb": "8d24e520361b7e2c",
        "name": "Ghost",
        "measurement": "strategy/ghost_mode",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "organisation",
        "bucket": "bucket",
        "x": 2210,
        "y": 1240,
        "wires": []
    },
    {
        "id": "3e5341549e80473c",
        "type": "change",
        "z": "90b4bf1bba3c4a1b",
        "g": "8759a84d80e51cc0",
        "name": "To Number",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "$number(payload)",
                "tot": "jsonata"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1170,
        "y": 960,
        "wires": [
            [
                "9ee12cef89a4ae99"
            ]
        ]
    },
    {
        "id": "9a3a852fb5e25bec",
        "type": "change",
        "z": "90b4bf1bba3c4a1b",
        "g": "8759a84d80e51cc0",
        "name": "To Number",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "$number(payload)",
                "tot": "jsonata"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1850,
        "y": 760,
        "wires": [
            [
                "cc03ecb002548446"
            ]
        ]
    },
    {
        "id": "c268619a93b7e2ed",
        "type": "change",
        "z": "90b4bf1bba3c4a1b",
        "g": "8759a84d80e51cc0",
        "name": "To Number",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "$number(payload)",
                "tot": "jsonata"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1170,
        "y": 1040,
        "wires": [
            [
                "258a61d8b59d36c6"
            ]
        ]
    },
    {
        "id": "fa6a33cd942a9c83",
        "type": "mqtt-broker",
        "name": "RPI",
        "broker": "localhost",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "8d24e520361b7e2c",
        "type": "influxdb",
        "hostname": "127.0.0.1",
        "port": "8086",
        "protocol": "http",
        "database": "sensors",
        "name": "",
        "usetls": false,
        "tls": "",
        "influxdbVersion": "1.x",
        "url": "http://localhost:8086",
        "timeout": "10",
        "rejectUnauthorized": true
    }
]